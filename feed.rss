<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Каморка сурового программиста, дубль 2</title><description>Блог о технологиях, преимущественно о Swift и обо всём, что связано с Apple</description><link>https://sparklone.github.io</link><language>ru</language><lastBuildDate>Sun, 27 Jun 2021 17:57:33 +0300</lastBuildDate><pubDate>Sun, 27 Jun 2021 17:57:33 +0300</pubDate><ttl>250</ttl><atom:link href="https://sparklone.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://sparklone.github.io/articles/working-with-data-in-swiftui</guid><title>Как работать с данными в SwiftUI</title><description>Как работать с данными в SwiftUI: @State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject. Разбираемся какие и когда стоит использовать.</description><link>https://sparklone.github.io/articles/working-with-data-in-swiftui</link><pubDate>Sun, 27 Jun 2021 15:30:00 +0300</pubDate><content:encoded><![CDATA[<h1>Как работать с данными в SwiftUI</h1><p>SwiftUI богат обертками для работы с данными. Подробней ознакомиться с тем, что такое Property Wrapper'ы (обертки) и с чем их едят можно в моей предыдущей статье <a href="https://sparklone.github.io/articles/property-wrappers-in-swift/">Property Wrappers в Swift</a></p><p>Так что в этой статье мы рассмотрим практическое применение существующих оберток для работы с данными в SwiftUI.</p><p>Основной момент: если меняется значение внутри переменной любой из указанных оберток, и эта переменная используется внутри переменной body, - переменная body будет вычислена повторно, таким образом View обновится (перерисуется).</p><p>Итак, первой оберткой является State.</p><h2>@State</h2><p>Исходя из документации Apple <a href="https://developer.apple.com/documentation/swiftui/state">State</a> необходимо использовать для хранения данных конкретной View. <a href="https://developer.apple.com/documentation/swiftui/state-and-data-flow">Здесь</a> Apple советует в @State хранить именно UI состояние, а не бизнес логику. <em>"Manage transient UI state locally within a view by wrapping value types as State properties."</em></p><p>Более того очень важно работать с этой переменной только внутри View, где она была объявлена, причем только из переменной body, или из методов которые вызываются из переменной body. Поэтому всегда стоит @State объявлять приватной переменной.</p><p><em>"You should only access a state property from inside the view’s body, or from methods called by it. For this reason, declare your state properties as private, to prevent clients of your view from accessing them. It is safe to mutate state properties from any thread."</em></p><p>Приведу простой пример использования @State, он искусственный (как раз View-счетчик обычно полезно инициализировать значениями извне), но с ним проще играться.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> SimplestState: <span class="type">View</span> {
    <span class="keyword">@State private var</span> counter = <span class="number">0</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"counter:</span> \(counter)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">HStack</span>(spacing: <span class="number">20</span>) {
                <span class="type">Button</span>(<span class="string">"Increase"</span>) {
                    counter += <span class="number">1</span>
                }

                <span class="type">Button</span>(<span class="string">"Decrease"</span>) {
                    counter = <span class="call">max</span>(<span class="number">0</span>, counter - <span class="number">1</span>)
                }
                .<span class="call">disabled</span>(counter == <span class="number">0</span>)
            }
        }
    }
}

<span class="keyword">struct</span> SimplestState_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">SimplestState</span>()
    }
}

</code></pre><p>Хотел бы обратить внимание еще на одну вещь. Хранить в @State стоит только простые типы (Int, String, Bool) ну или в крайнем случае - структуры, но ни в коем случае не классы. Почему? Ну просто потому что с классами State не будет работать.</p><p>Об этом косвенно упоминается в документации фразой <em>"When the state value changes, the view invalidates its appearance and recomputes the body."</em> Подозреваю, что если бы был протокол, который ограничивает что его может реализовать только структура, но не класс - данная обертка бы его использовала (по аналогии с AnyObject для классов).</p><p>Если мы используем @State для структуры, то любое изменение любого ее поля по факту "под капотом" приведет к созданию новой копии структуры, которая перепишет значение в State переменной, что вызовет перерисовку View.</p><p>В случае же класса этого не произойдет. Но не стоит мне верить на слово, show me the code!</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> Datas {
<span class="comment">//class Datas {</span>

    <span class="keyword">var</span> int: <span class="type">Int</span>
    <span class="keyword">var</span> string: <span class="type">String</span>

    <span class="keyword">internal init</span>(int: <span class="type">Int</span>, string: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">int</span> = int
        <span class="keyword">self</span>.<span class="property">string</span> = string
    }

}

<span class="keyword">struct</span> StateExample: <span class="type">View</span> {
    <span class="keyword">@State private var</span> datas = <span class="type">Datas</span>(int: <span class="number">1</span>, string: <span class="string">"String"</span>)
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">14</span>) {
            <span class="type">Text</span>(<span class="string">"datas int:</span> \(datas.<span class="property">int</span>)<span class="string">"</span>)
            <span class="type">Button</span>(<span class="string">"Change int"</span>) {
                datas.<span class="property">int</span> += <span class="number">1</span>
            }

            <span class="type">Text</span>(<span class="string">"datas string:</span> \(datas.<span class="property">string</span>)<span class="string">"</span>)
            <span class="type">Button</span>(<span class="string">"Change string"</span>) {
                datas.<span class="property">string</span> += <span class="string">"."</span>
            }
        }
    }
}

<span class="keyword">struct</span> StateExample_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">StateExample</span>()
    }
}
</code></pre><p>Нажатие на кнопки приводит к ожидаемым изменениям только если Datas - struct, если же Datas сделать class - изменение полей класса не приводит к изменению всей переменной datas, и код стоящий за propertyWrapper @State не подхватит изменение объекта и не выполнит повторное вычисление переменной body.</p><h4>Таким образом используем @State:</h4><br/><ul><li>для того чтобы хранить внутреннее состояние View, которое не надо сохранять между сессиями работы приложения.</li></ul><p>К примеру у View которая является кастомной кнопкой можно добавить флаг нажата кнопка или нет. Подразумевая, что если мы создаем кнопку - она всегда в значении по умолчанию. Или для id активного элемент списка. Обычно при заходе на экран со списком ни один элемент не выделен и это не задается снаружи.</p><ul><li>так же очень часто @State используют как черновик, во время прототипирования экрана, чтобы впоследствии перенести переменную в тот же ObservedObject.</li></ul><h2>@Binding</h2><p>Со @State вроде все понятно, но как передавать значение переменных объявленных как State внутренним компонентам, чтобы дети могли их изменять и чтобы изменения отражались и в родительской View? (мы же за модульную структуру).</p><p>Для этого и была создана обертка <a href="https://developer.apple.com/documentation/swiftui/binding">@Binding</a>, чтобы установить двустороннюю связь в плане данных состояния View между родительской View и ее ребенком.</p><p>Заглянем в документацию, или чтобы ускорить процесс, можно воспользоваться инструментом Jump to Definition в Xcode. Если навести курсор мыши над словом @State в Xcode, нажать на клавиатуре ⌃ + ⌘ и нажать левую кнопку (по факту выполнить Jump to Definition), то мы увидим документацию по State прям внутри Xcode. Вообще рекомендую почаще заглядывать в документацию.</p><p>Благодаря этой документации можно убедиться, что projectedValue имеет тип <code>Binding&lt;Value&gt;</code> (доп информацию по projectedValue можно получить из прошлой <a href="https://sparklone.github.io/articles/property-wrappers-in-swift/">статьи</a> )</p><p>В приведенном ниже примере read/write доступ имеют как parent view (BindingExample), она отображает имя и может его обнулить с помощью кнопки Reset, так и child view ChildTextControl, которая в свою очередь делегирует изменение имени в системный контрол TextField</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> BindingExample: <span class="type">View</span> {
    <span class="keyword">@State private var</span> name = <span class="string">""</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">14</span>) {
            <span class="type">Text</span>(<span class="string">"Current name:</span> \(name)<span class="string">"</span>)
            
            <span class="type">Button</span>(<span class="string">"Reset"</span>) {
                name = <span class="string">""</span>
            }.<span class="call">disabled</span>(name.<span class="property">count</span> == <span class="number">0</span>)

            <span class="type">ChildTextControl</span>(text: $name)

            <span class="type">Spacer</span>()
        }.<span class="call">padding</span>([.<span class="dotAccess">top</span>, .<span class="dotAccess">bottom</span>])
    }
}

<span class="keyword">struct</span> ChildTextControl: <span class="type">View</span> {

    <span class="keyword">@Binding var</span> text: <span class="type">String</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">TextField</span>(<span class="string">"Enter name"</span>, text: $text)
            .<span class="call">padding</span>()
    }
}

<span class="keyword">struct</span> BindingExample_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">BindingExample</span>()
    }
}
</code></pre><p>В примере можно увидеть что ChildTextController ожидает в конструкторе <code></code><code>@Binding var text: String</code><code></code> а мы передаем <code></code><code>$name</code><code></code>.</p><p>В документации можно узнать, что подставляя символ $ перед State переменной мы по факту получаем projectedValue у State, а для State projectedValue имеет тип <code></code><code>Binding&lt;Value&gt;</code><code></code>, т.е. $name и есть Binding</p><p>И вновь таки применив Jump to Definition уже на @Binding мы можем увидеть, что конструктор структуры Binding в качестве параметров принимает замыкания get/set</p><pre><code><span class="keyword">public init</span>(get: <span class="keyword">@escaping</span> () -&gt; <span class="type">Value</span>, set: <span class="keyword">@escaping</span> (<span class="type">Value</span>) -&gt; <span class="type">Void</span>)
</code></pre><p>Таким образом Binding - это средство, которое позволяет работать с value типами как с reference. Ведь если мы передадим Int из одной View в другую - произойдет ее копирование и изменения в parent не будут отражаться в child, впрочем как и наоборот. А Binding - это фасад, который скрывает что под капотом он несет не сами данные а функции позволяющие читать/писать в оригинальное хранилище данных где лежит тот же наш Int.</p><p>Так же из документации можно подсмотреть, что Binding можно инициализировать константой, и полезно это при использовании Preview</p><pre><code><span class="keyword">public static func</span> constant(<span class="keyword">_</span> value: <span class="type">Value</span>) -&gt; <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt;
</code></pre><p>К примеру Preview к нашему компоненту ChildTextControl мог бы выглядеть так:</p><pre><code><span class="keyword">struct</span> ChildTextControl_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ChildTextControl</span>(text: .<span class="call">constant</span>(<span class="string">"test"</span>))
    }
}
</code></pre><p>Ну и если @State переменная хранит какую то структуру со своими полями (как вышеприведенная struct Datas), то можно передавать не всю ее ребенку а только нужное поле с помощью того же $ с указанием нужного поля</p><pre><code><span class="type">ChildTextControl</span>(text: $datas.<span class="property">string</span>)

</code></pre><h4>Таким образом область применения @Binding:</h4><br/><ul><li>передать доступ переменных обозначенных как @State / @Published внутрь дочерних компонентов</li></ul><h2>Протокол ObservableObject</h2><p>Обертки @StateObject, @EnvironmentObject, @ObservedObject будут работать с классами реализующими протокол ObservableObject, вот его определение</p><pre><code><span class="keyword">@available</span>(iOS <span class="number">13.0</span>, macOS <span class="number">10.15</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">6.0</span>, *)
<span class="keyword">public protocol</span> ObservableObject : <span class="type">AnyObject</span> {

    <span class="comment">/// The type of publisher that emits before the object has changed.</span>
    <span class="keyword">associatedtype</span> ObjectWillChangePublisher : <span class="type">Publisher</span> = <span class="type">ObservableObjectPublisher</span> <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">ObjectWillChangePublisher</span>.<span class="type">Failure</span> == <span class="type">Never</span>

    <span class="comment">/// A publisher that emits before the object has changed.</span>
    <span class="keyword">var</span> objectWillChange: <span class="type">Self</span>.<span class="type">ObjectWillChangePublisher</span> { <span class="keyword">get</span> }
}
</code></pre><p>Из определения протокола видно, что реализовать его могут только классы, по сути классы реализующие этот протокол будут являться полноценными контейнерами для данных, хранить данные бизнес логики, а не внутреннее состояние View (как @State).</p><p>И работать можно будет с каждым свойством отдельно за счет того, что у каждого свойства мы будем проставлять @Published, что под капотом использует фреймворк Combine. Как указано в документации, для ObservableObject определено свойство objectWillChange, которое будет генерировать событие <strong>перед</strong> каждым изменение свойств помеченных как @Published.</p><p>И если бы мы использовали ObservableObject напрямую, то код мог бы выглядеть как то так:</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">import</span> Combine

<span class="keyword">var</span> cancellables = <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()

<span class="keyword">class</span> Product: <span class="type">ObservableObject</span> {
    <span class="keyword">@Published var</span> title: <span class="type">String</span>
    <span class="keyword">@Published var</span> price: <span class="type">Double</span>

    <span class="keyword">init</span>(title: <span class="type">String</span>, price: <span class="type">Double</span>) {
        <span class="keyword">self</span>.<span class="property">title</span> = title
        <span class="keyword">self</span>.<span class="property">price</span> = price
    }

    <span class="keyword">func</span> increasePrice(by value: <span class="type">Double</span>) -&gt; <span class="type">Double</span> {
        price += value
        <span class="keyword">return</span> price
    }

}

<span class="keyword">let</span> product = <span class="type">Product</span>(title: <span class="string">"Phone"</span>, price: <span class="number">100.00</span>)
product.<span class="property">objectWillChange</span>
    .<span class="call">sink</span> { <span class="keyword">_ in</span>
        <span class="call">print</span>(<span class="string">"price '</span>\(product.<span class="property">price</span>)<span class="string">' will change"</span>)
    }
    .<span class="call">store</span>(in: &amp;cancellables)

<span class="call">print</span>(product.<span class="call">increasePrice</span>(by: <span class="number">50</span>))
</code></pre><p>Это выведет в консоль 100, а не 150, на то и willChange а не didChange</p><pre><code>price '<span class="number">100.0</span>' will change
<span class="number">150.0</span>
</code></pre><p>Мы так же можем с помощью Combine подписаться и на изменение конкретного поля</p><pre><code>product.$price.<span class="call">sink</span> { value <span class="keyword">in</span>
    <span class="call">print</span>(<span class="string">"direct $price access: price '</span>\(product.<span class="property">price</span>)<span class="string">' will change"</span>)
}.<span class="call">store</span>(in: &amp;cancellables)
</code></pre><p>Если вставить этот код перед print(product...), то в консоли будет</p><pre><code>direct $price access: price '<span class="number">100.0</span>' will change
price '<span class="number">100.0</span>' will change
direct $price access: price '<span class="number">100.0</span>' will change
<span class="number">150.0</span>
</code></pre><p>т.к. на момент подписки на $price там уже было значение - мы тут же его получаем, а следующий print из <code></code><code>product.$price.sink</code><code></code> отработает уже во время увеличения price. Убедиться в этом можно закомментировав <code></code><code>print(product.increasePrice(by: 50))</code><code></code> таким образом пусть мы вообще не изменяем объект product - все равно подписка <code></code><code>product.$price.sink</code><code></code> отработает, напечатав при этом в консоль одну строку:</p><pre><code>direct $price access: price '<span class="number">100.0</span>' will change
</code></pre><p>В принципе нам никто не запрещает в классе реализующем ObservableObject самим генерировать новые события в objectWillChange (хоть по таймеру) при необходимости.</p><p>Но мы в основном будем сталкиваться с ObservableObject именно в связке с SwiftUI, и мы будем напрямую работать со свойствами объектов реализующих ObservableObject, а события из objectWillChange будет перехватывать сам SwiftUI для того чтобы знать, что надо перерисовать View. По всей видимости именно для оптимизации эффективности генерируется willSet, а не didSet, т.к. это позволяет накапливать изменения и обновлять View реже.</p><p>Что же, рассмотрим первую обертку работающую с ObservableObject - ObservedObject.</p><h2>@ObservedObject</h2><p>Документация довольно немногословна, и говорит, что <a href="https://developer.apple.com/documentation/swiftui/observedobject">@ObservedObject</a> это обертка, которая подписывается на объект ObservableObject и обновляет View, когда данные объекта меняются. По сути это мост между данными хранящимися в ObservableObject и нашими View.</p><p>Кстати при выходе SwiftUI нам была доступна только эта обертка, @StateObject была добавлена позже (в так называемом SwiftUI 2.0, представленном на WWDC 2020), давайте на этом примере поймем почему пришлось добавить еще одну обертку.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">class</span> AppState: <span class="type">ObservableObject</span> {
    <span class="keyword">@Published var</span> counter: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">struct</span> ObservedObjectExample: <span class="type">View</span> {
    <span class="keyword">@State private var</span> mainCounter = <span class="number">0</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Main counter:</span> \(mainCounter)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                mainCounter += <span class="number">1</span>
            }

            <span class="type">Divider</span>().<span class="call">padding</span>()

            <span class="type">CounterView</span>()
        }.<span class="call">padding</span>()
    }
}

<span class="keyword">struct</span> CounterView: <span class="type">View</span> {
    <span class="keyword">@ObservedObject var</span> appState = <span class="type">AppState</span>()

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Child counter:</span> \(appState.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">HStack</span>(spacing: <span class="number">20</span>) {
                <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                    appState.<span class="property">counter</span> += <span class="number">1</span>
                }
                
                <span class="type">Button</span>(<span class="string">"Decrease"</span>) {
                    appState.<span class="property">counter</span> = <span class="call">max</span>(<span class="number">0</span>, appState.<span class="property">counter</span> - <span class="number">1</span>)
                }
                .<span class="call">disabled</span>(appState.<span class="property">counter</span> == <span class="number">0</span>)
            }
        }
    }
}

<span class="keyword">struct</span> ObservedObjectExample_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ObservedObjectExample</span>()
    }
}
</code></pre><p>Во View верхнего уровня ObservedObjectExample мы отображаем как @State счетчик mainCounter (в Text), так и ребенка CounterView, у которого внутри создается переменная типа AppState с указанной оберткой @ObservedObject</p><p>На первый взгляд проблем нет никаких, мы можем нажать кнопку "Increase main" для Main counter и это честно увеличит <code></code><code>@State private var mainCounter</code><code></code>, обновив ObservedObjectExample. Мы можем нажать Increase/Decrease для ребенка CounterView, что изменит данные в переменной AppState и SwiftUI честно перерисует CounterView. Где подвох?</p><p>А подвох в том, что если еще раз нажать "Increase main" для Main counter, счетчик Child counter обнулится.</p><p>Почему так случилось? На самом деле все просто, при нажатии на "Increase main" меняется mainCounter, что вызывает пересчет переменной body для ObservedObjectExample, что в свою очередь вызывает пересоздание CounterView. А при повторном создании CounterView у нас вновь инициализируется переменная appState со счетчиком counter = 0. Если не ожидать этого - неожиданное пересоздание переменной может стать очень неприятным сюрпризом.</p><p>Таким образом сферой применения @ObservedObject можно было бы считать:</p><ul><li>если вам нужно, чтобы происходило пересоздание состояния. Хотя тяжело представить зачем такое может быть нужно, т.к. одно дело когда это ожидаемое поведение (переход со списка List в DetailView), а другое дело приведенный выше пример, когда дочерний компонент неожиданно сбрасывает свое состояние.</li></ul><ul><li>если вы уверены, что переменная никогда не будет уничтожена, создаем к примеру на старте приложения внутри того же WindowGroup</li></ul><br/><p>Но как будет пояснено в разделе с @StateObject даже это не стоит делать.</p><h4>Остается одно применение @ObservedObject:</h4><br/><ul><li>если вам надо уже созданную переменную класса реализующего ObservableObject передать вниз по иерархии.</li></ul><h2>@StateObject</h2><p>После WWDC 2020 нам добавили еще одну обертку - <a href="https://developer.apple.com/documentation/swiftui/stateobject">@StateObject</a>, спасителя от пересоздания переменной при перерисовке View.</p><p>Для того, чтобы починить баг со сбросом состояния дочерней View при увеличения счетчика родительской - достаточно в CounterView сменить @ObservedObject на @StateObject.</p><p>Вернемся к теории, в документации для <strong>@StateObject</strong> написано "A property wrapper type that <strong>instantiates</strong> an observable object.", в то время как для <strong>@ObservedObject</strong> "A property wrapper type that <strong>subscribes</strong> to an observable object and invalidates a view whenever the observable object changes."</p><p>Таким образом Apple прямо говорит - не стоит создавать самим ObservedObject внутри View которое будет его использовать, создавать нужно только StateObject, а уже в дочерних View определять переменную как @ObservedObject.</p><p>Проследить путь appState и убедиться, что все причастные View работают с одним и тем же объектом appState можно в этом примере</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">class</span> AppState: <span class="type">ObservableObject</span> {
    <span class="keyword">@Published var</span> counter: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">struct</span> StateObjectTestView: <span class="type">View</span> {
    <span class="keyword">@StateObject private var</span> appState = <span class="type">AppState</span>()
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Observed Object"</span>)) {
                    <span class="type">NavigationLink</span>(
                        destination: <span class="type">NestedObservedObjectExample</span>(state: appState),
                        label: {
                            <span class="type">Text</span>(<span class="string">"Nested ObservedObject Example"</span>)
                        })
                }
            }
        }
    }
}

<span class="keyword">struct</span> NestedObservedObjectExample: <span class="type">View</span> {
    <span class="keyword">@ObservedObject var</span> state: <span class="type">AppState</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Main counter:</span> \(state.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                state.<span class="property">counter</span> += <span class="number">1</span>
            }

            <span class="type">Divider</span>().<span class="call">padding</span>()

            <span class="type">NestedCounterView</span>(appState: state)
        }.<span class="call">padding</span>()
    }
}

<span class="keyword">struct</span> NestedCounterView: <span class="type">View</span> {
    <span class="keyword">@ObservedObject var</span> appState: <span class="type">AppState</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Child counter:</span> \(appState.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">HStack</span>(spacing: <span class="number">20</span>) {
                <span class="type">Button</span>(<span class="string">"Increase"</span>) {
                    appState.<span class="property">counter</span> += <span class="number">1</span>
                }

                <span class="type">Button</span>(<span class="string">"Decrease"</span>) {
                    appState.<span class="property">counter</span> = <span class="call">max</span>(<span class="number">0</span>, appState.<span class="property">counter</span> - <span class="number">1</span>)
                }
                .<span class="call">disabled</span>(appState.<span class="property">counter</span> == <span class="number">0</span>)
            }
        }
    }
}

<span class="keyword">struct</span> StateObjectTestView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">StateObjectTestView</span>()
    }
}
</code></pre><p>Видно, что в корневой View (а можно было и в WindowGroup) мы определяем переменную как @StateObject, а во всех дочерних как @ObservedObject, и где бы мы не меняли appState.counter - данные будут обновлены во всех View.</p><p>Важно отметить, что @StateObject привязывается к конкретному экземпляру View, не к типу View.</p><h4>Область применения @StateObject:</h4><br/><ul><li>создавать объекты с данными внутри View, будучи уверенным, что они не обнулятся при перерисовке этого View. И это важный момент, если же пересоздастся родительская View (вернулись по навигационному стеку назад и зашли снова на родительскую View к примеру), то уже пересоздадутся и дочерние View, соответственно пересоздадутся и дочерние переменные, хоть они и @StateObject. Т.е. не стоит думать, что если мы пометили переменную как @StateObject, то она вообще никогда не пересоздастся, это работает только в рамках пересоздания внутри body родительской View.</li></ul><h2>@EnvironmentObject</h2><p>Практически Dependency Injection из коробки. По сути мало чем отличается от ObservedObject, в том смысле, что parent создает переменную, а дочерняя View получает к этой переменной доступ. Разница в том, что прикрепляя эту переменную к родительской View - все дети, и дети детей и т.д получают к ней доступ. Особенно это удобно, если эта переменная нужна только на самых нижних уровнях, т.к. нет необходимости прокидывать через все View посредники. Есть подводный камень, не всегда ясно, будет ли передан environmentObject для дочерних View созданных посредтвом alert, sheet, navigationLink. На WWDC 2021 разработчики apple рекомендовали для этих случаев проставлять вручную envirionmentObject</p><p>Original Question: I’ve had several intermittent crashes from environment objects being nil when I pass them to a sheet or NavigationLink. It’s tricky to replicate due to being intermittent and I usually work around it by architecting my code differently to avoid passing environment objects. Do you know of reasons this might happen? All I can think of is that the views that originate the environmentObject further up the view hierarchy are being taken out of memory. Thanks for any help you can provide!</p><p>Answer (engineer #1): NavigationLink by design doesn’t flow EnvironmentObjects through to its destination as it’s unclear where the environmentObject should be inherited from. I suspect this might what’s causing your issue. In order to get the behavior you expect, you’ll have to explicitly pass the environmentObject through at that point.</p><p>Answer (engineer #2):You can also apply the environmentObject to the NavigationView itself, which will make it available to all pushed content.</p><pre><code>

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@StateObject private var</span> appState = <span class="type">AppState</span>()
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
            	...
            	<span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Environment Object"</span>)) {
                    <span class="type">NavigationLink</span>(
                        destination: <span class="type">EnvironmentObjectExample</span>()
                            .<span class="call">environmentObject</span>(appState),
                        label: {
                            <span class="type">Text</span>(<span class="string">"EnvironmentObject Example"</span>)
                        })
                }
            ...
}     



<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> EnvironmentObjectExample: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Main"</span>)
            <span class="type">Child1EnvironmentObjectExample</span>()
        }
    }
}

<span class="keyword">struct</span> Child1EnvironmentObjectExample: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Child1"</span>)
            <span class="type">Child2EnvironmentObjectExample</span>()
        }
    }
}

<span class="keyword">struct</span> Child2EnvironmentObjectExample: <span class="type">View</span> {
    <span class="keyword">@EnvironmentObject var</span> appState: <span class="type">AppState</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Child2"</span>)
            <span class="type">Text</span>(<span class="string">"Environment counter:</span> \(appState.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                appState.<span class="property">counter</span> += <span class="number">1</span>
            }
        }
    }
}
</code></pre><p>Из примера можно извлечь следующее:</p><ul><li>чтобы проставить environmentObject нужно для корневой View проставить .environmentObject(&lt;object&gt;) <br/></li></ul><ul><li>получать доступ можно в любой дочернeй View на любой глубине с помощью</li></ul><br/><pre><code><span class="keyword">@EnvironmentObject var</span> varName: <span class="type">Type</span> 
</code></pre><ul><li>создавать объекты для environment так же стоит с помощью @StateObject. Но нужно быть очень аккуратным, т.к. если мы забыли проставить <code>.environmentObject(object)</code> - при попытке открыть View использующее отсутствующий EnvironmentObject - вылетит Fatal error.</li></ul><br/><p>Так же естественным ограничением является то, что можно положить в Environment только один объект определенного типа для конкретной иерархии View, т.к. доступ идет по типу, а не по имени (.environmentObject(&lt;object&gt;))</p><h4>Область применения @EnvironmentObject:</h4><br/><ul><li>если объект используется детьми View и нужен всего 1 объект данного типа, особенно если объект нужен не всем View в цепочке создания, а где то глубоко внизу в цепочке созданных View, чтобы не передавать постоянно ObservedObject явно от родителя к ребенку, коль большинству View это все равно это не нужно.</li></ul><br/><h4>Про остальные обертки вкратце:</h4><br/><p>Есть так же обертки для частных случаев. Подробно я их разбирать не буду, просто упомяну</p><ul><li>@AppStorage, по сути прокси для UserDefaults</li><li>@FetchRequest, позволяет получить доступ к CoreData объектам из View</li><li>@SceneStorage, в основном используется для state restoration, чтобы после перезапуска приложения мы могли показать приложение в том виде в котором оно находилось перед закрытием (положение, позиция внутри экрана и т.д.)</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/property-wrappers-in-swift</guid><title>Property Wrappers в Swift</title><description>Разбираемся что таке Property Wrappers в Swift, как они устроены, какие есть возможности и подводные камни.</description><link>https://sparklone.github.io/articles/property-wrappers-in-swift</link><pubDate>Mon, 16 Nov 2020 02:00:00 +0300</pubDate><content:encoded><![CDATA[<h1>Property Wrappers в Swift</h1><p>В рамках предложения <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md">SE-0258 Property Wrappers</a> в Swift добавили возможность к свойствам добавлять обертки. В основном это было сделано для SwiftUI. Чтобы было проще работать с данными добавили <strong>@State</strong>, <strong>@Binding</strong>, <strong>@ObservedObject</strong> и т.д.</p><p>Я бы не сказал, что Property Wrappers очень сложны для понимания, но стоит в них разобраться получше, т.к. есть и нюансы. Итак, что такое property wrapper? Из самого названия можно догадаться, что это обертка над свойством, которая добавляет логику к этому свойству.</p><p>Перед тем как углубляться в более сложные примеры давайте создадим простейшую обертку-пустышку, которая по сути ничего не делает, просто хранит значение. Исходя из <strong>SE-0258</strong>, чтобы создать свою обертку необходимо</p><ol><li>чтобы перед типом стоял атрибут <strong>@propertyWrapper</strong></li><li>тип обязан содержать переменную <strong>wrappedValue</strong> с уровнем доступа не ниже, чем у самого типа</li></ol><br/><p>Итого простейший пример будет выглядеть так:</p><pre><code><span class="keyword">@propertyWrapper
struct</span> Simplest&lt;T&gt; {
    <span class="keyword">var</span> wrappedValue: <span class="type">T</span>
}
</code></pre><p>Попробуем применить нашу обертку:</p><pre><code><span class="keyword">struct</span> TestSimplest {
    <span class="keyword">@Simplest var</span> value: <span class="type">String</span>
}

<span class="keyword">let</span> simplest = <span class="type">TestSimplest</span>(value: <span class="string">"test"</span>)
<span class="call">print</span>(simplest.<span class="property">value</span>)

</code></pre><p>В консоли будет выведено: test</p><p>Но если внимательно изучить proposal, то мы обнаружим как внутри объекта раскрываются property wrapper'ы на самом деле</p><pre><code><span class="keyword">struct</span> TestSimplest {
    <span class="keyword">@Simplest var</span> value: <span class="type">String</span>

    <span class="comment">// будет развернуто в</span> 
    <span class="keyword">private var</span> _value: <span class="type">Simplest</span>
    <span class="keyword">var</span> value: <span class="type">String</span> { <span class="comment">/* доступ через _value.wrappedValue */</span> }
}
</code></pre><p>За счет приватности снаружи мы не можем получить доступ к wrapper'у <strong>print(simplest._value)</strong> выдаст ошибку</p><p>Но изнутри типа мы вполне можем получить доступ к самому wrapper'у напрямую</p><pre><code><span class="keyword">extension</span> <span class="type">TestSimplest</span> {
    <span class="keyword">func</span> describe() {
        <span class="call">print</span>(<span class="string">"value:</span> \(value) <span class="string">type:</span> \(<span class="call">type</span>(of: value))<span class="string">"</span>)
        <span class="call">print</span>(<span class="string">"_value:</span> \(_value) <span class="string">type:</span> \(<span class="call">type</span>(of: _value))<span class="string">"</span>)
        <span class="call">print</span>(<span class="string">"_value.wrappedValue:</span> \(_value.<span class="property">wrappedValue</span>) <span class="string">type:</span> \(<span class="call">type</span>(of: _value.<span class="property">wrappedValue</span>))<span class="string">"</span>)
    }
}

<span class="keyword">let</span> simplest = <span class="type">TestSimplest</span>(value: <span class="string">"test"</span>)
simplest.<span class="call">describe</span>()
</code></pre><p>Это выведет</p><pre><code>value: test type: <span class="type">String</span>
_value: <span class="type">Simplest</span>&lt;<span class="type">String</span>&gt;(wrappedValue: <span class="string">"test"</span>) type: <span class="type">Simplest</span>&lt;<span class="type">String</span>&gt;
_value.<span class="property">wrappedValue</span>: test type: <span class="type">String</span>
</code></pre><p>что подтверждает, что _value - реальная обертка, а value == _value.wrappedValue == String</p><p>Разобравшись с простейшим примером попробуем создать что то чуть более полезное, к примеру обертку для целых чисел со следующей логикой - если присваивается отрицательное число - делаем его положительным, по сути обертка над функцией <strong>abs</strong></p><pre><code><span class="keyword">@propertyWrapper
struct</span> Abs {
    <span class="keyword">private var</span> value: <span class="type">Int</span> = <span class="number">0</span>

    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> {
        <span class="keyword">get</span> { value }
        <span class="keyword">set</span> {
            value = <span class="call">abs</span>(newValue)
        }
    }

    <span class="keyword">init</span>(wrappedValue: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">wrappedValue</span> = wrappedValue
    }
}

<span class="keyword">struct</span> TestAbs {
    <span class="keyword">@Abs var</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">var</span> testAbs = <span class="type">TestAbs</span>(value: -<span class="number">10</span>)
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = <span class="number">20</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = -<span class="number">30</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
</code></pre><p>В консоли будет</p><pre><code><span class="number">10
20
30</span>
</code></pre><p>Логику мы поместили в set для <strong>wrappedValue</strong>, в совокупности с инициализатором в котором мы присваиваем изначальное значение в свойство <strong>wrappedValue</strong> это позволяет нам получить нужное поведение как при инициализации переменной с оберткой, так и при дальнейшем ее изменении, в результате отрицательного числа не может быть в value в принципе. Обращаю внимание, что важно, чтобы в инициализаторе первым параметром шел параметр с именем wrappedValue, это позволяет swift'у под капотом позволять вот такие вот присваивания, когда мы в переменную помеченную оберткой можем присвоить значение того типа, который она содержит</p><pre><code><span class="keyword">@Abs var</span> value: <span class="type">Int</span> = <span class="number">0</span>
</code></pre><p>если мы поменяем к примеру на</p><pre><code><span class="keyword">init</span>(custom: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">wrappedValue</span> = custom
}
</code></pre><p>это уже не будет работать</p><p>Стоит отметить, что т.к. по факту реализуют <strong>@propertyWrapper</strong> самые обычные типы, мы можем параметризовать обертки.</p><p>К примеру создадим обертку Uppercased, которая принимает на вход так же число символов, которое необходимо конвертировать в upper case с начала строки.</p><pre><code><span class="keyword">@propertyWrapper
struct</span> Uppercased {
    <span class="keyword">private var</span> count: <span class="type">Int</span>
    <span class="keyword">private var</span> value: <span class="type">String</span> = <span class="string">""</span>

    <span class="keyword">var</span> wrappedValue: <span class="type">String</span> {
        <span class="keyword">get</span> { value }
        <span class="keyword">set</span> {
            <span class="keyword">let</span> uppercased = <span class="type">String</span>(newValue.<span class="call">prefix</span>(count)).<span class="call">uppercased</span>()
            value = uppercased
            <span class="keyword">guard let</span> from = newValue.<span class="call">index</span>(newValue.<span class="property">startIndex</span>, offsetBy: count, limitedBy: newValue.<span class="property">endIndex</span>) <span class="keyword">else</span> { <span class="keyword">return</span> }
            value += newValue.<span class="call">suffix</span>(from: from)
        }
    }

    <span class="keyword">init</span>(wrappedValue: <span class="type">String</span>, count: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">count</span> = count
        <span class="keyword">self</span>.<span class="property">wrappedValue</span> = wrappedValue
    }

}

<span class="keyword">struct</span> TestUppercased {
    <span class="keyword">@Uppercased</span>(count: <span class="number">5</span>) <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span>
}

<span class="keyword">var</span> testAbs = <span class="type">TestUppercased</span>(value: <span class="string">"hello world"</span>)
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = <span class="string">"another example"</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = <span class="string">"abc"</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
</code></pre><p>В консоли будет</p><pre><code><span class="type">HELLO</span> world
<span class="type">ANOTHer</span> example
<span class="type">ABC</span>
</code></pre><p>Так же хотел бы обратить внимание на "магию", этот пример не будет компилироваться, если в <strong>TestUppercased</strong> мы уберем присваивание строки, т.е. под капотом</p><pre><code><span class="keyword">@Uppercased</span>(count: <span class="number">5</span>) <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span> 
</code></pre><p>вызывает <code></code><code>init(wrappedValue: String, count: Int)</code><code></code>, в качестве <strong>wrappedValue</strong> как раз передается значение которое мы присваиваем в value</p><p>Чтобы обойти это ограничение придется инициализацию проводить в конструкторе,</p><pre><code><span class="keyword">struct</span> TestUppercased2 {
    <span class="keyword">@Uppercased var</span> value: <span class="type">String</span>

    <span class="keyword">init</span>(count: <span class="type">Int</span>, example: <span class="type">String</span>) {
        _value = <span class="type">Uppercased</span>(wrappedValue: example, count: count)
    }
}

<span class="keyword">var</span> testAbs2 = <span class="type">TestUppercased2</span>(count: <span class="number">3</span>, example: <span class="string">"super puper"</span>)
<span class="call">print</span>(testAbs2.<span class="property">value</span>)
</code></pre><p>Если вы успели поработать со <strong>SwiftUI</strong> то думаю обратили внимание на переменные предваренные знаком доллара <strong>$value</strong>, их мы обычно передаем в дочернюю <strong>View</strong>, у которой переменная определена как <strong>@Binding</strong>. Proposal поясняет, для чего это нужно. Вспомним, что происходит если объявить переменную как <strong>PropertyWrapper</strong>, - снаружи типа невозможно будет получить к ней доступ</p><pre><code><span class="keyword">struct</span> TestSimplest {
    <span class="keyword">@Simplest var</span> value: <span class="type">String</span>

    <span class="comment">// будет развернуто в</span> 
    <span class="keyword">private var</span> _value: <span class="type">Simplest</span>
    <span class="keyword">var</span> value: <span class="type">String</span> { <span class="comment">/* доступ через _value.wrappedValue */</span> }
}
</code></pre><p>А что если мы хотим, чтобы пользователи структуры <strong>TestSimplest</strong> имели доступ к логике обертки ее свойства? Для этого надо в property wrapper определить свойство <strong>projectedValue</strong>.</p><pre><code><span class="keyword">@propertyWrapper
struct</span> VarWithMemory&lt;T&gt; {
    <span class="keyword">private var</span> _current: <span class="type">T</span>
    <span class="keyword">private (set) var</span> previousValues: [<span class="type">T</span>] = []

    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> {
        <span class="keyword">get</span> { _current }
        <span class="keyword">set</span> {
            previousValues.<span class="call">append</span>(_current)
            _current = newValue
        }
    }

    <span class="keyword">var</span> projectedValue: <span class="type">VarWithMemory</span>&lt;<span class="type">T</span>&gt; {
        <span class="keyword">get</span> { <span class="keyword">self</span> }
        <span class="keyword">set</span> { <span class="keyword">self</span> = newValue }
    }

    <span class="keyword">init</span>(wrappedValue: <span class="type">T</span>) {
        <span class="keyword">self</span>.<span class="property">_current</span> = wrappedValue
    }

    <span class="keyword">mutating func</span> clear() {
        previousValues.<span class="call">removeAll</span>()
    }

}

<span class="keyword">struct</span> TestVarWithMemory {
    <span class="keyword">@VarWithMemory var</span> value: <span class="type">String</span> = <span class="string">""</span>
}

<span class="keyword">var</span> test = <span class="type">TestVarWithMemory</span>(value: <span class="string">"initial"</span>)
<span class="call">print</span>(<span class="string">"1. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)
test.<span class="property">value</span> = <span class="string">"second"</span>
<span class="call">print</span>(<span class="string">"2. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)
test.<span class="property">value</span> = <span class="string">"third"</span>
<span class="call">print</span>(<span class="string">"3. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)

<span class="comment">// value: String, won't work
// print(test.value.previousValues)</span>

<span class="call">print</span>(<span class="string">"4. history:</span> \(test.$value.<span class="property">previousValues</span>)<span class="string">"</span>)
<span class="call">print</span>(<span class="string">"5. clear"</span>)
test.$value.<span class="call">clear</span>()
<span class="call">print</span>(<span class="string">"6. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)
<span class="call">print</span>(<span class="string">"7. history:</span> \(test.$value.<span class="property">previousValues</span>)<span class="string">"</span>)
</code></pre><p>Вывод в лог:</p><pre><code><span class="number">1</span>. <span class="property">current</span> value: initial
<span class="number">2</span>. <span class="property">current</span> value: second
<span class="number">3</span>. <span class="property">current</span> value: third
<span class="number">4</span>. <span class="property">history</span>: [<span class="string">"initial"</span>, <span class="string">"second"</span>]
<span class="number">5</span>. <span class="property">clear</span>
<span class="number">6</span>. <span class="property">current</span> value: third
<span class="number">7</span>. <span class="property">history</span>: []
</code></pre><p>Таким образом:</p><pre><code><span class="keyword">@VarWithMemory var</span> value: <span class="type">String</span> = <span class="string">""</span>
</code></pre><p>развернется во что то вроде</p><pre><code><span class="keyword">private var</span> _value: <span class="type">VarWithMemory</span>&lt;<span class="type">String</span>&gt; = <span class="type">VarWithMemory</span>(wrappedValue: <span class="string">""</span>)

<span class="keyword">public var</span> value: <span class="type">String</span> {
  <span class="keyword">get</span> { _value.<span class="property">wrappedValue</span> }
  <span class="keyword">set</span> { _value.<span class="property">wrappedValue</span> = newValue }
}

<span class="keyword">public var</span> $value: <span class="type">VarWithMemory</span>&lt;<span class="type">String</span>&gt; {
  <span class="keyword">get</span> { _value.<span class="property">projectedValue</span> }
  <span class="keyword">set</span> { _value.<span class="property">projectedValue</span> = newValue }
}
</code></pre><p>Важно отметит, что тип <strong>projectedValue</strong> может быть любой и не соответствовать типу в котором определена переменная. Это и позволило для <strong>@State</strong> при получении <strong>projectedValue</strong> через <strong>$</strong> - получать на выходе не <strong>State</strong>, а <strong>Binding</strong></p><p>Какие основные очевидные вариант применения можно придумать?</p><ul><li>когда работа со значением на самом деле проксируется и фактически переменная хранится в базе данных/<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults">User Defaults</a></li><li>когда мы хотим как то преобразовать значение при присваивании, примером этого может быть приведенные выше <strong>Abs</strong>, <strong>Uppercased</strong>, ну или из proposal'а <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#clamping-a-value-within-bounds">Clamping</a> для обрезания значение по min/max границам</li><li>реализация <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#copy-on-write">Copy on Write</a></li></ul><p>ну и т.д.</p><p>Надо отметить, что есть определенные ограничения применения property wrapper'ов</p><ul><li>в протоколе нельзя указать, что это свойство должно быть обьявлено с таким то <strong>Property wrapper</strong>'ом</li><li>свойство с property wrapper'ом нельзя использовать в <strong>extension</strong> и <strong>enum</strong></li><li>свойство с property wrapper'ом нельзя переопределить в наследнике класса</li><li>свойство с property wrapper'ом не может быть <strong>lazy</strong>, <strong>@NSCopying</strong>, <strong>@NSManaged</strong>, <strong>weak</strong>, или <strong>unowned</strong>.</li><li>свойство с property wrapper'ом не может иметь кастомный <strong>get/set</strong></li><li>уровень доступа <strong>wrappedValue</strong>, и уровни доступа для всего нижеперечисленного (если присутствуют) должны быть идентичны уровню доступа типа в котором они определены: <strong>projectedValue</strong>, <strong>init(wrappedValue:)</strong>, <strong>init()</strong></li></ul><br/><p>Кстати, хотя обертки можно комбинировать, - есть один нюанс. Комбинирование происходит по принципу матрешки, и к примеру такой код:</p><pre><code><span class="keyword">struct</span> TestCombined {
    <span class="keyword">@VarWithMemory @Abs var</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">var</span> test = <span class="type">TestCombined</span>()
<span class="call">print</span>(test.<span class="property">value</span>)
test.<span class="property">value</span> = -<span class="number">1</span>
test.<span class="property">value</span> = -<span class="number">2</span>
test.<span class="property">value</span> = -<span class="number">3</span>
<span class="call">print</span>(test.<span class="property">value</span>)
<span class="call">print</span>(test.$value.<span class="property">previousValues</span>)
</code></pre><p>выдаст в лог</p><pre><code><span class="number">0
3</span>
[__lldb_expr_173.<span class="type">Abs</span>(_value: <span class="number">0</span>), __lldb_expr_173.<span class="type">Abs</span>(_value: <span class="number">1</span>), __lldb_expr_173.<span class="type">Abs</span>(_value: <span class="number">2</span>)]
</code></pre><p>а не ожидаемые</p><pre><code><span class="number">0
3</span>
[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]

</code></pre><p>На вход в <strong>VarWithMemory</strong> приходит переменна не типа <strong>Int</strong>, а типа <strong>Abs&lt;Int&gt;</strong> А если бы обертки были не <strong>Generic</strong>, а принимали к примеру только строки, то это даже бы не скомпилировалось. Красивого решения нет, можно к примеру делать специализированные версии оберток, чтобы один тип принимал в конструкторе второй, а внутри уже работать со внутренним типом второго.</p><h2>Подводя итоги.</h2><p>Какие достоинства у property wrapper'ов? Они позволяют спрятать кастомную логику за простым определением переменной добавив <strong>@&lt;Тип&gt;</strong></p><p>Какие минусы?</p><p>С точки зрения практического применения они исходят из их главного плюса, сложность обертки скрыта от глаз, даже сам факт, что ты работаешь с оберткой не очевиден, пока не посмотришь определение переменной. Поэтому я порекомендовал бы аккуратно использовать их в своем проекте.</p><p>Какие альтернативы?</p><ul><li>для создании логики типа <strong>Observer</strong> - использовать <strong>willSet/didSet</strong> у свойств</li><li>для добавления логики модификации/места хранения - использовать <strong>get/set</strong> у свойств</li></ul><br/><p><strong>Playground</strong> с исходниками из статьи доступен <a href="https://github.com/sparklone/property-wrappers-in-swift">здесь</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/make-auto-updated-swifui-views-preview-list</guid><title>Личная поваренная книга SwiftUI рецептов.</title><description>Создаем авто пополняемый список preview для SwiftUI Views</description><link>https://sparklone.github.io/articles/make-auto-updated-swifui-views-preview-list</link><pubDate>Wed, 22 Jul 2020 02:00:00 +0300</pubDate><content:encoded><![CDATA[<h1>Личная поваренная книга SwiftUI рецептов.</h1><p>Когда начинаешь разбираться в какой то обширной теме в программировании - количество скачанных проектов, созданных черновиков начинает превышать все мыслимые и немыслимые пределы. А потом всё перемешивается, теряется. Вроде помнил, что ты с этим работал, а где, когда? Я пробовал работать в Playground'ах, но они на мой взгляд не такие стабильные как обычный проект, отваливается подсветка, нет возможности нормально делать Debug. С недавних пор я завел единый проект для исследования SwiftUI, и все небольшие вещи закидываю туда. Это помогает держать все в одном месте, к тому же поиск внутри проекта намного удобней. Хоть SwiftUI и предоставляет Preview для быстрого просмотра View, даже позволяет их отлаживать, все же этого не всегда хватает. Хочется и на устройстве проверить. А если держать все эти View внутри одного проекта - надо при создании новой вьюхи проставлять ее как основную в SceneDelegate, что довольно быстро начинает утомлять. Как было бы круто, если бы мы могли видеть все наши тестовые View при запуске приложения и могли выбрать с чем работать. Фантастика скажете вы? Отнюдь )</p><p>Задачу думаю можно решить более чем одним путем. Навскидку - прикрутить Sourcery, но интересно было решить без вспомогательных инструментов.</p><p>Итак, что из себя представляет View и её Preview:</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello, World!"</span>)
    }
}

<span class="keyword">struct</span> ContentView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>Как мы видим предпросмотр для view обеспечивается структурой, которая имплементирует PreviewProvider, если кто не знал, можно даже внутри одного файла создавать сколь угодно структур/классов, которые будут имплементировать PreviewProvider и в зоне предпросмотра они отобразятся все. Может пригодиться, если хотим разбить наш ContentView_Previews на неколько с разными настройками (хотя можно это же сделать и внутри одной структуры имплементирующей PreviewProvider, но речь не об этом).</p><p>Что из себя представляет PreviewProvider - это протокол</p><pre><code><span class="comment">/// Produces view previews in Xcode.
///
/// Xcode statically discovers types that conform to `PreviewProvider` and
/// generates previews in the canvas for each provider it discovers.</span>
<span class="keyword">@available</span>(iOS <span class="number">13.0</span>, <span class="type">OSX</span> <span class="number">10.15</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">6.0</span>, *)
<span class="keyword">public protocol</span> PreviewProvider : <span class="type">_PreviewProvider</span> {

    <span class="comment">/// The type of the previews variable.</span>
    <span class="keyword">associatedtype</span> Previews : <span class="type">View</span>

    <span class="comment">/// Generates a collection of previews.
    ///
    /// Example:
    ///
    ///     struct MyPreviews : PreviewProvider {
    ///         static var previews: some View {
    ///             return Group {
    ///                 GreetingView("Hello"),
    ///                 GreetingView("Guten Tag"),
    ///
    ///                 ForEach(otherGreetings, id: \.self) {
    ///                     GreetingView($0)
    ///                 }
    ///             }
    ///             .previewDevice("iPhone X")
    ///         }
    ///     }</span>
    <span class="keyword">static var</span> previews: <span class="type">Self</span>.<span class="type">Previews</span> { <span class="keyword">get</span> }

    <span class="comment">/// Returns which platform to run the provider on.
    ///
    /// When `nil`, Xcode infers the platform based on the file the
    /// `PreviewProvider` is defined in. This should only be provided when the
    /// file is in targets that support multiple platforms.</span>
    <span class="keyword">static var</span> platform: <span class="type">PreviewPlatform</span>? { <span class="keyword">get</span> }
}
</code></pre><p>Главное, что можно извлечь из кода, это не простой протокол, а PAT: Protocol with Associated Type, что сразу усложняет дело. Я перепробовал много вариантов как обеспечить нужную функциональность с минимальными усилиями.</p><p>Начнем с того как вообще можно подобные вещи делать real time? В Objective-C мы могли делать все что угодно с помощью reflection - получать список всех кассов, исследовать их свойства. В swift это все дело сильно ограничили, и Mirror не даст нам всего необходимого. Поэтому пришлось смотреть в сторону objc_getClassList, это метод из Obj-C рантайма, который позволяет получить список всех классов. К сожалению такого нет для Swift структур, поэтому пришлось обходится тем, что дали.</p><p>Разберем решение по частям.</p><p>Не получится нормально работать с системным протоколом PreviewProvider из за того, что он PAT, поэтом создадим Erase версию этого протокола</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">protocol</span> PreviewHolder {
    <span class="keyword">static var</span> anyPreviews: <span class="type">AnyView</span> { <span class="keyword">get</span> }
    <span class="keyword">static var</span> name: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">static var</span> starred: <span class="type">Bool</span> { <span class="keyword">get</span> }
}

<span class="keyword">extension</span> <span class="type">PreviewHolder</span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> anyPreviews: <span class="type">AnyView</span> {
        <span class="type">AnyView</span>(previews)
    }

    <span class="keyword">static var</span> name: <span class="type">String</span> {
        <span class="type">String</span>(describing: <span class="keyword">self</span>).<span class="call">replacingOccurrences</span>(of: <span class="string">"_Previews"</span>, with: <span class="string">""</span>)
    }

    <span class="keyword">static var</span> starred: <span class="type">Bool</span> { <span class="keyword">false</span> }
}
</code></pre><p>1. Как видно я стер тип у previews, создав обертку anyPreviews, которая будет возвращать AnyView. Я не очень люблю такие штуки, потенциальная потеря производительности, но т.к. это не production код, то на это можно закрыть глаза.</p><p>2. name - свойство возвращающее имя нашей View, как оно будет отображатсья в списке, учитывая что все Preview имеют автоматом генерируемые имена <code></code><code>ViewName_Previews</code><code></code> - можно <code></code><code>_Previews</code><code></code> отрезать.</p><p>3. Я добавил свойство starred, т.к. число View будет все увеличиваться, и начиная работать с новым куском кода хочется увидеть его сверху в списке. Это можно сделать переопределив у превьюхи для новой View это свойство, возвращая true.</p><p>Сам список выглядит довольно просто.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> PreviewsList: <span class="type">View</span> {

    <span class="keyword">@State private var</span> starred: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>] = []

    <span class="keyword">@State private var</span> general: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>] = []

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Starred"</span>)) {
                    <span class="type">SubList</span>(elements: starred)
                }
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"General"</span>)) {
                    <span class="type">SubList</span>(elements: general)
                }
            }.<span class="call">navigationBarTitle</span>(<span class="string">"Catalog"</span>)
                .<span class="call">onAppear</span> {
                    <span class="keyword">let</span> sorted = <span class="type">PreviewUtils</span>.<span class="call">parse</span>().<span class="call">sorted</span>(by: { (lhs, rhs) -&gt; <span class="type">Bool</span> <span class="keyword">in</span>
                        lhs.<span class="property">name</span> &lt; rhs.<span class="property">name</span>
                    })
                    <span class="keyword">self</span>.<span class="property">starred</span> = sorted.<span class="call">filter</span> { $0.<span class="property">starred</span> }
                    <span class="keyword">self</span>.<span class="property">general</span> = sorted.<span class="call">filter</span> { !$0.<span class="property">starred</span> }
            }
        }
    }
}

<span class="keyword">private struct</span> SubList: <span class="type">View</span> {
    <span class="keyword">var</span> elements: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>]
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ForEach</span>(<span class="number">0</span>..&lt;elements.<span class="property">count</span>, id: \.<span class="keyword">self</span>) { id <span class="keyword">in
            return</span> <span class="type">NavigationLink</span>(destination: <span class="keyword">self</span>.<span class="property">elements</span>[id].anyPreviews) {
                <span class="type">Text</span>(<span class="keyword">self</span>.<span class="property">elements</span>[id].name)
            }
        }
    }
}

<span class="keyword">struct</span> PreviewsList_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">PreviewsList</span>()
    }
}
</code></pre><p>Все View сортируются по имени и разбивается на 2 списка, starred и обычные. Выглядеть все будет примерно так:</p><br/><img src="https://sparklone.github.io/blog/images/make-auto-updated-swifui-views-preview-list/list.png" width="300"/><p>Ну и в SceneDelegate просто меняем основную вьюху</p><pre><code><span class="keyword">let</span> contentView = <span class="type">PreviewsList</span>()
</code></pre><p>Остался последний момент, как же сделать так, чтобы наши Preview попали в этот список:</p><ul><li>поменять struct на class</li><li>добавить поддержку PreviewHolder</li></ul><br/><p>т.е. вместо</p><pre><code><span class="keyword">struct</span> ContentView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>станет</p><pre><code><span class="keyword">class</span> ContentView_Previews: <span class="type">PreviewProvider</span>, <span class="type">PreviewHolder</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>Опционально можно переопределять name и starred.</p><p>Это решение написано за пару часов, чтобы по быстрому испытать идею. При желании его можно наворотить по полной, проставляя теги, дату создания для Preview, показывать список не основным, а в в Debug окне, что позволит использовать даже на боевом проекте (не забываем отключать в Release сборке). В общем все зависит от вашей фантазии )</p><p>Скачать проект с базовой реализацией можно здесь: <a href="https://github.com/sparklone/swiftui-views-preview-list" target="_blank">Github</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/debug-swiftui-views</guid><title>Отладка SwiftUI views</title><description>Как отслеживать создание и отрисовку SwiftUI views</description><link>https://sparklone.github.io/articles/debug-swiftui-views</link><pubDate>Sat, 11 Jul 2020 19:58:00 +0300</pubDate><content:encoded><![CDATA[<h1>Отладка SwiftUI views</h1><p>SwiftUI прикладывает массу усилий, чтобы UI не лагал при перерисовке. Если мы хотим лучше понимать как работает фреймворк под капотом - стоит копнуть чуть глубже.</p><p>По сути нас интересуют два события - когда View пересоздается, и когда запрашивается на самом деле body для перерисовки.</p><p>Это побудило меня создать обертку позволяющую отслеживать эти события</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">public struct</span> DebugView&lt;MainView: <span class="type">View</span>&gt;: <span class="type">View</span> {
    <span class="keyword">private let</span> view: <span class="type">MainView</span>
    <span class="keyword">private let</span> logType: <span class="type">LogType</span>

    <span class="keyword">private enum</span> LogType {
        <span class="keyword">case</span> onlyDescription(<span class="type">String</span>)
        <span class="keyword">case</span> descriptionAndDumpView(<span class="type">String</span>)
        <span class="keyword">case</span> dumpView
    }

    <span class="keyword">private var</span> about: <span class="type">String</span> {
        <span class="keyword">switch</span> logType {
            <span class="keyword">case let</span> .<span class="call">onlyDescription</span>(description):
                <span class="keyword">return</span> <span class="string">"</span>\(description)<span class="string">"</span>
            <span class="keyword">case let</span> .<span class="call">descriptionAndDumpView</span>(description):
                <span class="keyword">return</span> <span class="string">"</span>\(description)<span class="string">:</span> \(view)<span class="string">"</span>
            <span class="keyword">case</span> .<span class="dotAccess">dumpView</span>:
                <span class="keyword">return</span> <span class="string">"</span>\(view)<span class="string">"</span>
            }
        }

    <span class="keyword">public init</span>(view: <span class="type">MainView</span>, description: <span class="type">String</span>?, dumpView: <span class="type">Bool</span> = <span class="keyword">true</span>) {
        <span class="keyword">self</span>.<span class="property">view</span> = view
        <span class="keyword">if let</span> description = description {
            <span class="keyword">if</span> dumpView {
                logType = .<span class="call">descriptionAndDumpView</span>(description)
            } <span class="keyword">else</span> {
                logType = .<span class="call">onlyDescription</span>(description)
            }
        } <span class="keyword">else</span> {
            logType = .<span class="dotAccess">dumpView</span>
        }
        <span class="call">print</span>(<span class="string">"init:</span> \(about)<span class="string">"</span>)
    }

    <span class="keyword">public var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="call">print</span>(<span class="string">"body:</span> \(about)<span class="string">"</span>)
        <span class="keyword">return</span> view
    }
}

<span class="keyword">extension</span> <span class="type">View</span> {
    <span class="keyword">public func</span> debug() -&gt; <span class="type">DebugView</span>&lt;<span class="type">Self</span>&gt; {
        <span class="keyword">return</span> <span class="type">DebugView</span>(view: <span class="keyword">self</span>, description: <span class="keyword">nil</span>)
    }

    <span class="keyword">public func</span> debug(<span class="keyword">_</span> description: <span class="type">String</span>, dumpView: <span class="type">Bool</span> = <span class="keyword">false</span>) -&gt; <span class="type">DebugView</span>&lt;<span class="type">Self</span>&gt; {
        <span class="keyword">return</span> <span class="type">DebugView</span>(
            view: <span class="keyword">self</span>,
            description: description,
            dumpView: dumpView
        )
    }
}
</code></pre><p>Вот ее <a href="https://gist.github.com/sparklone/6f64156ed6de87c1020198d93f4c45a3">Gist</a></p><p>По большому счету, это View - прокси. Давайте попробуем поработать с этим. Создадим playground в котором мы посмотрим работу с SwiftUI views в динамике</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">private struct</span> MyListView: <span class="type">View</span> {
    <span class="keyword">@State var</span> numberOfViews: <span class="type">Int</span> = <span class="number">1</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(spacing: <span class="number">30</span>) {
            <span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
                <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>).<span class="call">debug</span>(<span class="string">"Text:</span> \(id)<span class="string">"</span>)
            }
            <span class="type">HStack</span> {
                <span class="type">Text</span>(<span class="string">"</span>\(numberOfViews)<span class="string">"</span>)
                <span class="type">Button</span>(<span class="string">"numberOfViews"</span>) {
                    <span class="keyword">self</span>.<span class="property">numberOfViews</span> += <span class="number">1</span>
                }
            }
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">MyListView</span>().<span class="call">debug</span>(<span class="string">"MyListView"</span>))
</code></pre><p>При старте в логах мы увидим</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">Text</span>: <span class="number">0</span>
body: <span class="type">Text</span>: <span class="number">0</span>

</code></pre><p>Выглядит разумно, при старте приложения система сначала создает MyListView, берет у нее body, видит что нужен один Text, создает его и затем уже у него просит body.</p><p>Нажимаем один раз на кнопку numberOfViews В логах добавится следующее:</p><pre><code>init: <span class="type">Text</span>: <span class="number">0</span>
init: <span class="type">Text</span>: <span class="number">1</span>
body: <span class="type">Text</span>: <span class="number">1</span>
</code></pre><p>А вот это уже интересно, мы видим, что пересоздания MyListView не происходит, что выглядит логично, а вот Text создается 2 раза (view стало 2 после увеличения счетчика), но body запросился только у нового элемента на экране.</p><p>Если еще раз нажать на кнопку numberOfViews увидим уже ожидаемое</p><pre><code>init: <span class="type">Text</span>: <span class="number">0</span>
init: <span class="type">Text</span>: <span class="number">1</span>
init: <span class="type">Text</span>: <span class="number">2</span>
body: <span class="type">Text</span>: <span class="number">2</span>
</code></pre><p>Т.е. body будет вызываться только для новых элементов.</p><p>Попробуем понять как и почему так работает система.</p><p>Создадим свою View - MyTextView и сделаем так, чтобы при каждом создании - генерировался уникальный контент</p><pre><code><span class="keyword">private struct</span> MyText: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(<span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>))<span class="string">"</span>)
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">MyText</span>().<span class="call">debug</span>(<span class="string">"MyText:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>На старте видим в логах</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">MyText</span>: <span class="number">0</span>
body: <span class="type">MyText</span>: <span class="number">0</span>

</code></pre><p>После нажатия на кнопку numberOfViews</p><pre><code>init: <span class="type">MyText</span>: <span class="number">0</span>
init: <span class="type">MyText</span>: <span class="number">1</span>
body: <span class="type">MyText</span>: <span class="number">1</span>
</code></pre><p>При этом, мы ожидаем, что на экране для ранее показанного элемента изменится число (random же как никак), но по факту число не меняется. Т.е. система создает MyText, но по всей видимости отбрасывает не перерисовывая. Почему? Потому что система считает, что все MyText - одинаковы, т.к. эта структура не реализует Equatable.</p><p>Проверим нашу догадку</p><pre><code><span class="keyword">private struct</span> MyTextEquatable: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>() {
        id = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>)
    }
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">MyTextEquatable</span>().<span class="call">debug</span>(<span class="string">"MyTextEquatable:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>Первый запуск</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
</code></pre><p>Нажимаем на кнопку</p><pre><code>init: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
init: <span class="type">MyTextEquatable</span>: <span class="number">1</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">1</span>
</code></pre><p>Заработало, это видно не только из логов, но и в preivew, после каждого нажатия кнопки - все числа меняются. Теперь кажется все встает на свои места, при каждом обновлении View система создает его детей (именно поэтому инициализаторы для View должны быть максимально легковесными, никакой "тяжелой" логики в конструктор помещать не стоит), сравнивает по протоколу Equatable - изменилось ли внутреннее состояние, если нет - система считает что перерисовка не нужна, т.к. View не обновилось.</p><p>Проверим, создадим следующее</p><pre><code><span class="keyword">private struct</span> StupidView: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">StupidView</span>, rhs: <span class="type">StupidView</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">StupidView</span>().<span class="call">debug</span>(<span class="string">"StupidView:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>При старте</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">StupidView</span>: <span class="number">0</span>
body: <span class="type">StupidView</span>: <span class="number">0</span>
</code></pre><p>После нажатия</p><pre><code>init: <span class="type">StupidView</span>: <span class="number">0</span>
init: <span class="type">StupidView</span>: <span class="number">1</span>
body: <span class="type">StupidView</span>: <span class="number">1</span>
</code></pre><p>Что за черт, мы же возвращаем false всегда при сравнении! Чтобы поотлаживать SwiftUI view надо будет создать полноценный проект и создать там новый файл с содержимым</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">private struct</span> MyListView: <span class="type">View</span> {
    <span class="keyword">@State var</span> numberOfViews: <span class="type">Int</span> = <span class="number">1</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(spacing: <span class="number">30</span>) {
            <span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
                <span class="type">StupidView</span>(id: id).<span class="call">debug</span>(<span class="string">"StupidView:</span> \(id)<span class="string">"</span>)
            }
            <span class="type">HStack</span> {
                <span class="type">Text</span>(<span class="string">"</span>\(numberOfViews)<span class="string">"</span>)
                <span class="type">Button</span>(<span class="string">"numberOfViews"</span>) {
                    <span class="keyword">self</span>.<span class="property">numberOfViews</span> += <span class="number">1</span>
                }
            }
        }
    }
}

<span class="keyword">private struct</span> StupidView: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">StupidView</span>, rhs: <span class="type">StupidView</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}

<span class="keyword">struct</span> EquatableSwiftUIStupid_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">MyListView</span>()
    }
}
</code></pre><p>Если в preview вызывать контекстное меню у кнопки play - появится возможность сделать Debug preview.</p><br/><img src="https://sparklone.github.io/blog/images/debug-swiftui-views/debug-preview.png" width="300"/><br/><br/><br/><p>Что мы наблюдаем при отладке? Точки останова срабатывают внутри var body, но не срабатывают внутри static func == Почему то система не вызывает наш метод для сравнения. Очень уж умный SwiftUI. В итоге я нашел как это обойти - использовать вместо Int класс обертку Holder. Видимо в этом случае SwiftUI решает все же положиться на предоставленную реализацию, т.к. у нас уже не простой value type.</p><p>Проверим</p><pre><code><span class="keyword">private class</span> Holder {
    <span class="keyword">var</span> id: <span class="type">Int</span>

    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }
}

<span class="keyword">private struct</span> StupidViewWithHolder: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> holder: <span class="type">Holder</span>
    <span class="keyword">init</span>(holder: <span class="type">Holder</span>) {
        <span class="keyword">self</span>.<span class="property">holder</span> = holder
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(holder.<span class="property">id</span>)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}

</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">StupidViewWithHolder</span>(holder: <span class="type">Holder</span>(id: id))
                    .<span class="call">debug</span>(<span class="string">"StupidViewWithHolder:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>При старте</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>

</code></pre><p>после нажатия</p><pre><code>init: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
init: <span class="type">StupidViewWithHolder</span>: <span class="number">1</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">1</span>
</code></pre><p>Наконец то мы добились реальной перерисовки элементов!</p><p>Стоит понимать, что не стоит на это закладываться при разработке, т.к. это внутреннее поведение SwiftUI, которое может измениться в любой момент. Но знания могут помочь понять что может вообще пойти не так и не тратить кучу времени на отладку реально сложных View. Теперь мы знаем очередной подводный камень SwiftUI, к тому же новый инструмент по дебагу View доказал свою состоятельность. Надеюсь было полезно )</p><p>Скачать Playground со всеми примерами из статьи можно здесь: <a href="https://github.com/sparklone/debug-swiftui-views">Playground</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/create-blog-using-swift-and-publish-and-deploy-to-github-pages</guid><title>Создаем блог на Swift с помощью Publish с размещением на GitHub Pages</title><description>Создаем блог на Swift с помощью Publish на GitHub Pages</description><link>https://sparklone.github.io/articles/create-blog-using-swift-and-publish-and-deploy-to-github-pages</link><pubDate>Fri, 10 Jul 2020 19:23:00 +0300</pubDate><content:encoded><![CDATA[<h1>Создаем блог на Swift с помощью Publish с размещением на GitHub Pages</h1><p>У меня уже есть блог, он на WordPress и я устал от всей этой свистопляски с обновлением версии, плагинов, возможности взлома и прочего. Это буквально убивает желание продолжать его развивать. Моя цель - делиться с миром своими мыслями и находками, но при этом иметь полный контроль над своим сайтом. С недавних пор Github Pages предоставила возможность хранить простенькие сайты у них. Никаких баз данных и PHP, статический сайт, как в старые добрые. Для блога - идеально. А т.к. процесс деплоя будет проходить через GitHub - будет прозрачная история всех изменений, и полный контроль над тем, что реально находится на сайте, трояны и прочая нечисть не пройдут.</p><p>Но они предлагают использовать Jekyll, статический генератор сайтов написанный на Ruby. Все же хочется отачивать мастерство в том языке, который ты используешь ежедневно, поэтому в качестве альтернативы я взял свежий статический генератор написанный на Swift от John Sundell.</p><p>Нам предстоит сделать 3 вещи:</p><ol><li><a href="#create-blog">создать блог на GitРub Pages</a></li><li><a href="#publish">разобраться с тем как работать с Publish</a></li><li><a href="#deploy">залить свой новый блог на GitРub Pages</a> <br/><br/> Итак, перейдем к пункту 1</li></ol><h2><a name="create-blog"></a> 1. Создадим блог на Github Pages.</h2><p>Официальная инструкция доступен по адресу <a href="https://pages.github.com">https://pages.github.com</a></p><p>Основное условие - login блога должен совпадать с вашим логином на GitHub. В моем случае это sparklone</p><ul><li>логинимся в GitHub</li><li>идем по адресу <a href="https://github.com/new">https://github.com/new</a></li><li>в качестве имени репозитория вводите <em>login</em>.github.io, в моем случае было sparklone.github.io</li><li>убеждаемся, что он будет Public</li><li>жмем Create Repository</li><li>все, наш блог уже доступен по адресу https://<em>login</em>.github.io</li></ul><br/><p>Но пока на сайте нет ни одного файл Можно переходить ко второму пункту</p><h2><a name="publish"></a> 2. Разберёмся с тем как работать с Publish</h2><p>Еще раз <a href="https://github.com/JohnSundell/Publish">Publish</a> - это статический генератор сайтов написанный на Swift, что позволяет выстраивать любую логику при генерации сайта, теги, карта сайта, rss, специфическая перелинковка. Все на что нам хватит фантазии. Одна из моих идей на будущее - попробовать писать статьи на двух языках, и чтобы настроенный шаблон умел это понимать и вставлять переключатель в статью к примеру. Не знаю дойдут ли когда нибудь до этого руки, но как идея - интересно.</p><p>Я предпочел установить напрямую через git, создал папку ~/Developer/tools и там выполнил</p><pre><code>git clone https://github.<span class="property">com</span>/<span class="type">JohnSundell</span>/<span class="type">Publish</span>.<span class="property">git</span>
cd <span class="type">Publish</span>
make
</code></pre><p>далее я создал папку где я планирую хранить свой сайт (точнее исходники его генератора), в моем случае это ~/Developer/my/blog</p><p>и внутри этой папки запускаем команду</p><pre><code>publish new
</code></pre><p>Это создаст новый сайт, список опций для команды можно узнать просто запустив в консоли publish</p><p><em>publish run</em> скомпилирует все исходники и запустит веб сервер на питоне (если прервать посредством Ctrl+C - веб сервер не умрет, и придется в процессах ковыряться чтобы убить Python)</p><p>Первая сборка занимает какое то время (подливаются нужные репозитории, компилируется все), при последующих запусках <em>publish run</em> - все происходит намного быстрее.</p><p>Открываем в браузере http://localhost:8000 и видим что получился за сайт</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/blog-initial.png" width="600"/><p>Не густо, но мы еще ничего собственно и не сделали, чтобы ожидать чего то большего.</p><p>Настройку стилей и прочие моменты я оставлю на потом. На сегодня вижу перед собой следующие задачи</p><ol><li>сделать изначальную настройку генератора для нашего сайта</li><li>поменять пути по которым будут лежать записи и настроить меню</li><li>добавить подсветку для исходных файлов и создание своей темы <br/><br/></li></ol><h3>1. Изначальная настройка генератора для нашего сайта</h3><br/><p>Посмотрим что нам сгенерировал Publish. Внутри папки будет файл Package.swift, его открываем XCode'ом (можно в консоли набрать open Package.swift), и это запускает процесс подтягивания всех нужных библиотек. На скрине видно что должно получится в итоге.</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/publish-initial-screen.png" width="600"/><p>Тестовая запись лежит в Content/posts/first-post.md Проверим, что мы можем что то изменить и это отразится на сайте Подправим текст в first-post.md (можно поменять дату, теги, описания, и сам контент)</p><p>В Xcode выбираем Mac в качества таргета для которого надо запускать и делаем Run проекту.</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/blog-how-to-run.png" width="600"/><p>После этого рефрешим веб страницу <a href="http://localhost:8000">http://localhost:8000</a></p><h4>2. Меняем пути по которым будут лежать записи и настраиваем меню</h4><p>Почему это важно сделать сразу? Если вы решите поменять пути после того как уже зальете часть постов - входящие ссылки на эти страницы станут невалидными, а т.к. это не свой сервер/VPS - будет довольно проблематично сделать редирект со старых ссылок на новые пути. Не невозможно (вот к примеру плагин для <a href="https://github.com/jekyll/jekyll-redirect-from">Jekyll</a>), но зачем создавать себе головную боль в будущем если можно ее избежать.</p><p>По умолчанию все записи лежать в папке posts. Учитывая что в дальнейшем хочется бить на категории, а posts - общее название, - лучше переименовать папку в articles. Так же не помешает добавить страницу about</p><p>Но наш генератор пока ничего не знает про это.</p><p>В main.swift поменяем на</p><pre><code><span class="keyword">struct</span> Blog: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> articles
        <span class="keyword">case</span> about
    }
}
</code></pre><p>Добавим файл <em>about.md</em> в папку <em>Content</em> и заполним немного информации о себе</p><p>К слову эту статью я пишу в XCode, редактируя md файл, и периодически запуская проект, чтобы посмотреть в браузере как это смотрится.</p><p>Я долго колебался заморачиваться ли с датой у файлов *.md, ну т.е. называть не my-article.md, а к примеру 2020-07-10-my-article.md. И все же решил отказаться от этой идеи. Т.к. в самих md файлах есть метаданные (поле date), это при желании позволит в будущем добавлять дату автоматически. И не придется следить за корректностью даты в имени файла, к тому же это убережет от расхождений, если в имени файла одна дата, а в метаданных внутри - другая. Недостатком такого решения я вижу то, что гипотетически могут в будущем быть коллизии в именах md файлов, но все таки это маловероятно, к тому же мы об этом узнаем при создании поста, а не сохранении.</p><h4>3. Добавляем подсветку для исходных файлов</h4><p>Автором генератора Publish так же была написана библиотека <a href="https://github.com/JohnSundell/Splash">Splash</a> позволяющая делать подсветку исходных кодов. Подключается она как package в Swift Package Manager</p><p>Открываем файл Package.swift и добавляем поддержку, по сути нужно добавить 2 строки Вот что получилось у меня</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    name: <span class="string">"Blog"</span>,
    products: [
        .<span class="call">executable</span>(
            name: <span class="string">"Blog"</span>,
            targets: [<span class="string">"Blog"</span>]
        )
    ],
    dependencies: [
        .<span class="call">package</span>(name: <span class="string">"Publish"</span>, url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.6.0"</span>),
        .<span class="call">package</span>(name: <span class="string">"SplashPublishPlugin"</span>, url: <span class="string">"https://github.com/johnsundell/splashpublishplugin"</span>, from: <span class="string">"0.1.0"</span>)
    ],
    targets: [
        .<span class="call">target</span>(
            name: <span class="string">"Blog"</span>,
            dependencies: [
                <span class="string">"Publish"</span>,
                <span class="string">"SplashPublishPlugin"</span>
            ]
        )
    ]
)
</code></pre><p>А чтобы подсветка начала применяться при генерации нужно подклбючить плагин в main.swift</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>я поменял на</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">foundation</span>,
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><p>Не забываем добавить в <em>main.swift</em> импорт плагина <code></code><code>import SplashPublishPlugin</code><code></code></p><p>Если сгенерировать сайт сейчас мы увидим, что блоки с кодом будут выделяться, но не подсвечиваться, это связано с тем, что нужно добавить <a href="https://github.com/JohnSundell/Splash/blob/master/Examples/sundellsColors.css">CSS</a>, будем использовать тот, который по умолчанию используется автором плагина.</p><p>Но вот проблема - куда добавлять этот CSS? Если покопаться в исходниках, то станет видно, что все это решается на уровне темы. Тема у нас стандартная <em>foundation</em>, и она лежит в самом пакете <em>Publish</em> по пути <a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/Theme%2BFoundation.swift">Sources/Publish/API/Theme+Foundation.swift</a></p><p>Внутри своего проекта (Blog) в папке где лежит <em>main.swift</em> я создал подобный файл <em>Theme+Blog.swift</em> Так же внутри папки Resources я создал папку Blog и поместил туда файл styles.css Внутрь файла я поместил содержимое CSS от темы <a href="https://github.com/JohnSundell/Publish/blob/master/Resources/FoundationTheme/styles.css">Foundation</a> ну и CSS от <a href="https://github.com/JohnSundell/Splash/blob/master/Examples/sundellsColors.css">Splash</a> Да, лучше было бы разделить, а может вообще темы вынести в отдельный package, но не будем усложнять раньше времени.</p><p>Итого у меня в файле темы пришлось поменять на следующее</p><pre><code><span class="keyword">import</span> Plot
<span class="keyword">import</span> Publish

<span class="keyword">public extension</span> <span class="type">Theme</span> {
    <span class="keyword">static var</span> blog: <span class="type">Self</span> {
        <span class="type">Theme</span>(
            htmlFactory: <span class="type">BlogHTMLFactory</span>(),
            resourcePaths: [<span class="string">"resources/blog/styles.css"</span>]
        )
    }
}
</code></pre><p>Если бы мы добавили еще один css, нам потребовалось бы не только добавит его в resourcePaths, но так же добавлять в каждый head страниц, чего мне делать совершенно не хотелось в данный момент</p><pre><code>.<span class="call">head</span>(for: item, on: context.<span class="property">site</span>, stylesheetPaths: [<span class="string">"/styles.css"</span>, <span class="string">"/splash.css"</span>]),
</code></pre><p>Итого сейчас у меня в проекте файловая структура выглядит как то так:</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/final-structure.png" width="400"/><h2><a name="deploy"></a> 3. Зальём свой новый блог на GitРub Pages</h2><p>Итак, воспользуемся встроенным инструментом Publish для заливки нашего блога. В <em>main.swift</em> добавим</p><pre><code>.<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"login/login.github.io"</span>, useSSH: <span class="keyword">false</span>))
</code></pre><p>итого у меня получилось</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">blog</span>,
    deployedUsing: .<span class="call">gitHub</span>(<span class="string">"sparklone/sparklone.github.io"</span>, useSSH: <span class="keyword">false</span>),
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><p>Проверяем в последний раз, что все работает. Последний штрих - мне кажется, что нет смысла хранить в git нашего репозитория с темплейтами как строить сайт содержимое папки Output, для этого у нас будет отдельный репозиторий как раз таки <em>login.github.io</em> Если вы согласны - исключим эту папку из .gitignore, добавив туда строку <em>/Output</em> в конце Если все ок выполняем в консоли (из папки где мы выполняли publish new)</p><pre><code>git add .
git commit -m <span class="string">"post title or some description"</span>
git push origin
publish deploy
</code></pre><p>В течении минуты GitHub Pages подхватит ваши изменения и все появится онлайн.</p><br/><p>Поздравляю! )</p>]]></content:encoded></item></channel></rss>