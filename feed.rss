<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Каморка сурового программиста, дубль 2</title><description>Блог о технологиях, преимущественно о Swift и обо всём, что связано с Apple</description><link>https://sparklone.github.io</link><language>ru</language><lastBuildDate>Sun, 31 Oct 2021 17:14:22 +0300</lastBuildDate><pubDate>Sun, 31 Oct 2021 17:14:22 +0300</pubDate><ttl>250</ttl><atom:link href="https://sparklone.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://sparklone.github.io/articles/dynamic-delete-elements-from-lists-in-swiftui</guid><title>Динамическое удаление элементов из списков в SwiftUI, проблемы и решения.</title><description>Проблемы с удалением элемента списка когда открыт дочерний экран и их решение.</description><link>https://sparklone.github.io/articles/dynamic-delete-elements-from-lists-in-swiftui</link><pubDate>Sun, 31 Oct 2021 17:00:00 +0300</pubDate><content:encoded><![CDATA[<h1>Динамическое удаление элементов из списков в SwiftUI, проблемы и решения.</h1><p>Для начала поговорим о списках в SwiftUI. Если конкретнее - о том как передавать из родительской View данные в дочерние экраны. Вот ссылка на проект, в котором можно найти исходный код из статьи: <a href="https://github.com/sparklone/SwiftUILists">Исходники</a>. Должен предупредить, что компилируется только в Xcode 13, чтобы можно было запустить в 12м надо дорабатывать напильником, т.к. новая SwiftUI конструкция для обхода массива с поддержкой Binding в Xcode 12 не поддерживается.</p><p>Начнем с базового вопроса, зачем нужны списки, какие аналоги в UIKit? Списком в SwiftUI является List, аналогом в UIKit будет UITableView, более того изначальная реализация List под капотом явно была построена поверх UITableView.</p><p>Что можно сказать хорошого про списки в SwiftUI? Они прям очень простые, ими очень приятно пользоваться.. Когда это работает. Что можно сказать плохого? Работает это далеко не всегда, и что хуже всего поведение меняется от версии к версии iOS, что совсем не хорошо.</p><p>Следующие примеры можно найти в ListsPlayground внутри проекта</p><ul><li>Простейший список "1. ConstantList":</li></ul><br/><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">Text</span>(<span class="string">"First"</span>)
            <span class="type">Text</span>(<span class="string">"Second"</span>)
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">ContentView</span>())
</code></pre><p>И все, простейшая статическая табличка. Можно помещать внутрь любые кастомные View</p><p>Но статика это скучно, а если хочется динамически строить список?</p><ul><li>Тоже не сложно, "2. ListFromVar":</li></ul><br/><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">struct</span> Element {
    <span class="keyword">var</span> name: <span class="type">String</span>
}

<span class="keyword">struct</span> ListFromVar: <span class="type">View</span> {
    <span class="keyword">@State private var</span> elements: [<span class="type">Element</span>] = [
        .<span class="keyword">init</span>(name: <span class="string">"First"</span>),
        .<span class="keyword">init</span>(name: <span class="string">"Second"</span>)
    ]
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span>(elements, id: \.<span class="property">name</span>) { element <span class="keyword">in</span>
            <span class="type">Text</span>(element.<span class="property">name</span>)
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">ListFromVar</span>())
</code></pre><p>Списку надо указать по какому признаку элемент будет уникальным, в нашем случае это name. Конечно обычно используется уникальный id (если в нашем примере сделать два "First" - будут проблемы). И чтобы упростить жизнь, можно указать для нашей модели, что она реализует протокол Identifiable, требованием протокола является наличие переменной id: Hashable. UUID удовлетворяет этому условию. Это позволяет не указывать id: .id в параметрах для List</p><ul><li>"3. ListFromVarId":</li></ul><br/><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">struct</span> Element: <span class="type">Identifiable</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span> = <span class="type">UUID</span>()
    <span class="keyword">var</span> name: <span class="type">String</span>
}

<span class="keyword">struct</span> ListFromVar: <span class="type">View</span> {
    <span class="keyword">@State private var</span> elements: [<span class="type">Element</span>] = [
        .<span class="keyword">init</span>(name: <span class="string">"First"</span>),
        .<span class="keyword">init</span>(name: <span class="string">"Second"</span>),
        .<span class="keyword">init</span>(name: <span class="string">"First"</span>)
    ]
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span>(elements) { element <span class="keyword">in</span>
            <span class="type">Text</span>(element.<span class="property">name</span>)
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">ListFromVar</span>())

</code></pre><p>А что если мы захотим свайпом удалять элементы из списка? С этим нам поможет ForEach внутри List, к которому можно добавлять модификаторы. В нашем случае нужен модификатор onDelete</p><ul><li>"4. ListForEach":</li></ul><br/><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">struct</span> Element: <span class="type">Identifiable</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span> = <span class="type">UUID</span>()
    <span class="keyword">var</span> name: <span class="type">String</span>
}

<span class="keyword">struct</span> ListForEach: <span class="type">View</span> {
    <span class="keyword">@State private var</span> elements: [<span class="type">Element</span>] = [
        .<span class="keyword">init</span>(name: <span class="string">"First"</span>),
        .<span class="keyword">init</span>(name: <span class="string">"Second"</span>),
        .<span class="keyword">init</span>(name: <span class="string">"First"</span>)
    ]
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">ForEach</span>(elements) { element <span class="keyword">in</span>
                <span class="type">Text</span>(element.<span class="property">name</span>)
            }
            .<span class="call">onDelete</span> { indexSet <span class="keyword">in</span>
                elements.<span class="call">remove</span>(atOffsets: indexSet)
            }
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">ListForEach</span>())
</code></pre><p>И последний кубик знаний, которого нам не хватает. Как сделать, чтобы по нажатию на элемент списка происходила навигация внутрь нового экрана? С этим поможет NavigationLink, Ну и обязательно на самом верхнем уровне должна быть NavigationView.</p><ul><li>"5. ListNavigation":</li></ul><br/><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">struct</span> Element: <span class="type">Identifiable</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span> = <span class="type">UUID</span>()
    <span class="keyword">var</span> name: <span class="type">String</span>
}

<span class="keyword">struct</span> ListElement: <span class="type">View</span> {
    <span class="keyword">let</span> element: <span class="type">Element</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(element.<span class="property">name</span>)
            .<span class="call">foregroundColor</span>(.<span class="dotAccess">red</span>)
    }
}

<span class="keyword">struct</span> ListForEach: <span class="type">View</span> {
    <span class="keyword">@State private var</span> elements: [<span class="type">Element</span>] = [
        .<span class="keyword">init</span>(name: <span class="string">"First"</span>),
        .<span class="keyword">init</span>(name: <span class="string">"Second"</span>),
        .<span class="keyword">init</span>(name: <span class="string">"First"</span>)
    ]
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">ForEach</span>(elements) { element <span class="keyword">in</span>
                    <span class="type">NavigationLink</span>(destination: <span class="type">ListElement</span>(element: element)) {
                        <span class="type">Text</span>(element.<span class="property">name</span>)
                    }
                }
                .<span class="call">onDelete</span> { indexSet <span class="keyword">in</span>
                    elements.<span class="call">remove</span>(atOffsets: indexSet)
                }
            }
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">ListForEach</span>())

</code></pre><p>По сути мы быстро пробежались по основам списка и готовы начать разбираться с более интересными вопросами, а что к примеру произойдет, если в тот момент как мы перешли из списка на дочерний экран - элемент будет удален из списка? Или будет ли обновляться дочерний экране, если поменялось значение текущего элемента?</p><p>Дальнейшие примеры будут уже не в плейграунде, а внутри проекта. Вкратце пробегусь по структуре проекта.</p><ul><li>SwiftUIListDataFlowApp - точка входа</li><li>ViewModifiers/NavigationButtons, хелпер позволяющий добавлять кнопки обновления записи и ее удаления в одну строчку (withEditNavigationButtons)</li><li>Helpers/ForEach+Binding - хелпер позволяющий на Xcode 12 использовать биндинги с ForEach. Но сразу предупреждаю, использование этого кода может приводить к крешам, он представлен скорее в виде исторической справки как приходилось ухищряться до введения Apple'ом нативного решения.</li><li>папка Models - здесь находится наша структура данных User, и manager позволяющий работать со списком пользователей - UsersManager: ObservableObject</li><li>папка Views - как не сложно догадаться содержит все View<ul><li>UsersView - основная View, сделана в виде статического списка позволяющего открывать рассматриваемые нами примеры</li></ul></li></ul><br/><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> UsersView: <span class="type">View</span> {
    <span class="keyword">private static var</span> firstRun = <span class="keyword">true
    @EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Read only"</span>)) {
                <span class="type">NavigationLink</span>(destination: <span class="type">ListViewConstants</span>(checkDeletion: <span class="keyword">false</span>)) {
                    <span class="type">Text</span>(<span class="string">"Simple list without bindings"</span>)
                }
                <span class="type">NavigationLink</span>(destination: <span class="type">ListViewConstants</span>(checkDeletion: <span class="keyword">true</span>)) {
                    <span class="type">Text</span>(<span class="string">"Simple list without bindings, check deletion"</span>)
                }
                <span class="type">NavigationLink</span>(destination: <span class="type">UserViewCheckDeletion</span>(user: usersManager.<span class="property">users</span>.<span class="property">first</span> ?? <span class="type">UsersAPI</span>.<span class="property">dumpUsers</span>[<span class="number">1</span>])) {
                    <span class="type">Text</span>(<span class="string">"Just user:</span> \((usersManager.<span class="property">users</span>.<span class="property">first</span> ?? <span class="type">UsersAPI</span>.<span class="property">dumpUsers</span>[<span class="number">1</span>]).<span class="property">name</span>)<span class="string">"</span>)
                }
                <span class="type">NavigationLink</span>(destination: <span class="type">ListViewIndices</span>()) {
                    <span class="type">Text</span>(<span class="string">"Simple list without bindings, indices"</span>)
                }
            }
            <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"With bindings, Readonly"</span>)) {
                <span class="type">NavigationLink</span>(destination: <span class="type">ListViewBinding</span>()) {
                    <span class="type">Text</span>(<span class="string">"List with custom bindings"</span>)
                }
                <span class="type">NavigationLink</span>(destination: <span class="type">ListWithBindingsXcode13</span>(userViewKind: .<span class="dotAccess">readonly</span>)) {
                    <span class="type">Text</span>(<span class="string">"List with Xcode 13 bindings, no check deletion"</span>)
                }
                <span class="type">NavigationLink</span>(destination: <span class="type">ListWithBindingsXcode13</span>(userViewKind: .<span class="dotAccess">checkDeletion</span>)) {
                    <span class="type">Text</span>(<span class="string">"List with Xcode 13 bindings, check deletion"</span>)
                }
                <span class="type">NavigationLink</span>(destination: <span class="type">ListWithBindingsXcode13</span>(userViewKind: .<span class="dotAccess">useCache</span>)) {
                    <span class="type">Text</span>(<span class="string">"List with Xcode 13 bindings, check deletion, cache users"</span>)
                }
            }
            <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"With bindings, Editable"</span>)) {
                <span class="type">NavigationLink</span>(destination: <span class="type">ListWithBindingsXcode13</span>(userViewKind: .<span class="dotAccess">editable</span>)) {
                    <span class="type">Text</span>(<span class="string">"List with Xcode 13 bindings, editable"</span>)
                }
            }
        }
        .<span class="call">navigationBarTitle</span>(<span class="string">"Lists of lists =)"</span>, displayMode: .<span class="dotAccess">inline</span>)
    }
}

<span class="keyword">struct</span> UsersView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">UsersView</span>()
    }
}

</code></pre><ul><li>UserInfoView - простая вьюшка отображающая свойства модели, используется другими вьюшками, чтобы не повторяться<ul></ul></li></ul><br/><pre><code><span class="keyword">struct</span> UserInfoView: <span class="type">View</span> {
    <span class="keyword">let</span> user: <span class="type">User</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Name:</span> \(user.<span class="property">name</span>)<span class="string">"</span>)
            <span class="type">Text</span>(<span class="string">"Surname:</span> \(user.<span class="property">surname</span>)<span class="string">"</span>)
            <span class="type">Text</span>(<span class="string">"Views:</span> \(user.<span class="property">views</span>)<span class="string">"</span>)
        }
    }
}
</code></pre><ul><li>Lists, папка внутри которой указаны различные подходы к тому как делать списки<ul><li>UserViewVariations, папка внутри которой помещены всевозможные вариации View для показа и манипулирования данными выбранного User</li></ul></li></ul><p>Итак, начнем с простейшего случая, когда у нас список проходится по всем элементам массива, и передает элемент как копию внутрь дочерней View Запускаем приложение и выбираем пункт "Simple list without bindings"</p><p>Список строится этой View</p><br/><pre><code><span class="keyword">struct</span> ListViewConstants: <span class="type">View</span> {
    <span class="keyword">let</span> checkDeletion: <span class="type">Bool</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">ForEach</span>(usersManager.<span class="property">users</span>) { user <span class="keyword">in
                let</span> _ = <span class="call">print</span>(user)
                <span class="keyword">if</span> checkDeletion {
                    <span class="type">NavigationLink</span>(
                        destination: <span class="type">UserViewCheckDeletion</span>(user: user),
                        label: { <span class="type">Text</span>(user.<span class="property">name</span>) }
                    )
                } <span class="keyword">else</span> {
                    <span class="type">NavigationLink</span>(
                        destination: <span class="type">UserView</span>(user: user),
                        label: { <span class="type">Text</span>(user.<span class="property">name</span>) }
                    )
                }

            }
            .<span class="call">onDelete</span> { indexSet <span class="keyword">in</span>
                usersManager.<span class="call">removeUsers</span>(indexSet: indexSet)
            }
        }
        .<span class="call">navigationBarTitle</span>(<span class="string">"Constants list"</span>, displayMode: .<span class="dotAccess">inline</span>)
    }
}
</code></pre><p>Вызов будет как ListViewConstants(checkDeletion: false), поэтому отработает ветка else { и будет показана простейшая UserView</p><br/><pre><code><span class="keyword">struct</span> UserView: <span class="type">View</span> {
    <span class="keyword">let</span> user: <span class="type">User</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">UserInfoView</span>(user: user)
            .<span class="call">withEditNavigationButtons</span>(user: user, usersManager: usersManager)
            .<span class="call">onAppear</span> {
                <span class="call">print</span>(<span class="string">"UserView appear with user:</span> \(user)<span class="string">"</span>)
            }
    }
}
</code></pre><p>Если зайти внутрь какого либо элемента, мы увидим экран:</p><br/><img src="https://sparklone.github.io/blog/images/dynamic-delete-elements-from-lists-in-swiftui/static-list.png" width="300" border="1"/><br/><p>У нас есть в навигации две кнопки: Update и Delete, первая просит менеджер проставить текущему User имя равное "New name", вторая удаляет текущий User. Т.к. внутри View передается user обычной переменной, не через @Binding, нам по хорошему надо извлечь id от User и по этому id искать - есть ли в списке пользователь с таким id. Чтобы не делать это в каждой View, UsersManager имеет метод, у которого это все производится под капотом</p><br/><pre><code><span class="keyword">func</span> set(name: <span class="type">String</span>, to user: <span class="type">User</span>) <span class="keyword">throws</span> {
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> { [<span class="keyword">self</span>] <span class="keyword">in</span>
        <span class="call">print</span>(<span class="string">"try to set name</span> \(name) <span class="string">for</span> \(user)<span class="string">"</span>)
        <span class="keyword">guard let</span> index = users.<span class="call">firstIndex</span>(where: { $0.<span class="property">id</span> == user.<span class="property">id</span> }) <span class="keyword">else</span> {
            <span class="call">print</span>(<span class="string">"can't find user:</span> \(user)<span class="string">"</span>)
            <span class="keyword">return</span>
        }
        users[index].name = name
    }
}
</code></pre><p>Проверяем работу кнопки Update, после нажатия мы видим, что хоть сама ссылка на UsersManager была в родительской View, обновление данных происходит и в дочерней View. Теперь нажимаем Delete, и тут важный момент, все сильно зависит от условий запуска приложения.</p><ul><li>если таргетом является устройство на основе iOS 15 то при нажатии Delete<ul><li>если выбран первый элемент в списке, - нас выкинет на сам список система</li><li>если не первый - ничего не произойдет, мы останемся на дочернем экране</li></ul></li></ul><ul><li>если таргетом является устройство на основе iOS 14 то при нажатии Delete ничего не произойдет, не зависимо от индекса выбранного элемента. <br/> И это тот самый момент, о котором я говорил в начале статьи. Не очень весело наблюдать за тем, как идентичный, я бы сказал простейший код отрабатывает настолько по разному на разных версиях iOS.</li></ul><br/><p>Вот и попробуем как то обойти эту проблему, чтобы при удалении элемента на основе которого показан дочерний экран из менеджера мы могли покинуть дочерний экран прописав необходимую реакцию (P.S. в нашем случае удаление вызвано нами же, естественно не проблема сделать любую реакцию по нажатию на кнопку Delete, речь идет о том, если удаление произошло по какому то событию вне нашего контроля, вернулся результат какого то сетевого запроса или еще что случилось)</p><br/><p>onChange</p><br/><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> UserViewCheckDeletion: <span class="type">View</span> {
    <span class="keyword">let</span> user: <span class="type">User</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">@State private var</span> userWasDeleted: <span class="type">Bool</span> = <span class="keyword">false
    @Environment</span>(\.<span class="property">presentationMode</span>) <span class="keyword">var</span> presentationMode

<span class="comment">//    init(user: User) {
//        print("init: UserViewCheckDeletion with user \(user)")
//        self.user = user
//    }</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">UserInfoView</span>(user: user)
            .<span class="call">withEditNavigationButtons</span>(user: user, usersManager: usersManager)
<span class="comment">//            .onAppear {
//                print("UserViewCheckDeletion appear with user: \(user)")
//            }</span>
            .<span class="call">alert</span>(isPresented: $userWasDeleted, content: {
                <span class="type">Alert</span>(
                    title: <span class="type">Text</span>(<span class="string">"User was deleted"</span>),
                    dismissButton: <span class="type">Alert</span>.<span class="type">Button</span>.<span class="call">cancel</span>(<span class="type">Text</span>(<span class="string">"OK"</span>), action: {
                        presentationMode.<span class="property">wrappedValue</span>.<span class="call">dismiss</span>()
                    })
                )
            })
            .<span class="call">onChange</span>(of: usersManager.<span class="property">users</span>) { users <span class="keyword">in</span>
                <span class="call">print</span>(<span class="string">"UserViewCheckDeletion (onChange) users update:</span> \(users)<span class="string">"</span>)
                <span class="keyword">if</span> !users.<span class="call">map</span>(\.<span class="property">id</span>).<span class="call">contains</span>(user.<span class="property">id</span>) {
                    userWasDeleted = <span class="keyword">true</span>
                }
            }
<span class="comment">//            .onReceive(usersManager.$users) { users in
//                print("UserViewCheckDeletion (onReceive) users update: \(users)")
//                if !users.map(\.id).contains(user.id) {
//                    userWasDeleted = true
//                }
//            }</span>
    }
}
</code></pre><p>Идея была в следующем, есть такой метод, onChange, он генерирует новые данные каждый раз когда они обновляются, то что нам надо.</p><p>Запускаем программу на iOS 15, выбираем пункт "Simple list without bindings, check deletion, заходим на любого пользователя, жмем Delete и все отрабатывает как надо. В метод onChange прилетает обновленный список users,в нем уже отсутствует тот, которым был инициирован экран, соответственно мы понимаем, что элемент был удален, ну и реагируем, показываем алерт и выполняем навигацию на предыдущий экран.</p><p>Хорошо, что все это отрабатывает даже для первого элемента (как мы помним в предыдущем примере в iOS 15 при удалении первого элемента система сама без предупреждения выкидывает на список обратно). Плохо то.. Что это не работает для iOS 14. Запускаем симулятор для iOS 14, повторяем все шаги, нажатие на Delete не приводит визуально ни к чему. Починить это можно двумя способами.</p><ol><li>раскомментировать строчку .navigationViewStyle(StackNavigationViewStyle())</li></ol><br/><pre><code><span class="keyword">struct</span> SwiftUIListDataFlowApp: <span class="type">App</span> {
    <span class="keyword">let</span> usersManager = <span class="type">UsersManager</span>(usersApi: <span class="type">UsersAPI</span>())
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> {
        <span class="type">WindowGroup</span> {
            <span class="type">NavigationView</span> {
                <span class="type">UsersView</span>()
            }
<span class="comment">//            .navigationViewStyle(StackNavigationViewStyle())</span>
            .<span class="call">environmentObject</span>(usersManager)
            .<span class="call">onAppear</span> {
                usersManager.<span class="call">getUsers</span>()
            }
        }
    }
}

</code></pre><p>это поменяет тип навигации, по умолчанию используется DoubleColumnNavigationViewStyle, баг может быть из за двойного вложения списка в список. Но если код будет и на iPad - то потеряем возможность иметь две колонки (SplitView), нужно в общем выбирать надо или нет это.</p><ol start="2"><li>вместо как мне кажется более подходящего onChange использовать onReceive, минусом данного подхода будет то, что onReceive срабатывает чаще, при заходе на экран в том числе, так что следует быть аккуратней</li></ol><br/><pre><code><span class="keyword">struct</span> UserViewCheckDeletion: <span class="type">View</span> {
    <span class="keyword">let</span> user: <span class="type">User</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">@State private var</span> userWasDeleted: <span class="type">Bool</span> = <span class="keyword">false
    @Environment</span>(\.<span class="property">presentationMode</span>) <span class="keyword">var</span> presentationMode

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">UserInfoView</span>(user: user)
            .<span class="call">withEditNavigationButtons</span>(user: user, usersManager: usersManager)
<span class="comment">//            .onAppear {
//                print("UserViewCheckDeletion appear with user: \(user)")
//            }</span>
            .<span class="call">alert</span>(isPresented: $userWasDeleted, content: {
                <span class="type">Alert</span>(
                    title: <span class="type">Text</span>(<span class="string">"User was deleted"</span>),
                    dismissButton: <span class="type">Alert</span>.<span class="type">Button</span>.<span class="call">cancel</span>(<span class="type">Text</span>(<span class="string">"OK"</span>), action: {
                        presentationMode.<span class="property">wrappedValue</span>.<span class="call">dismiss</span>()
                    })
                )
            })
<span class="comment">//            .onChange(of: usersManager.users) { users in
//                print("UserViewCheckDeletion (onChange) users update: \(users)")
//                if !users.map(\.id).contains(user.id) {
//                    userWasDeleted = true
//                }
//            }</span>
            .<span class="call">onReceive</span>(usersManager.$users) { users <span class="keyword">in</span>
                <span class="call">print</span>(<span class="string">"UserViewCheckDeletion (onReceive) users update:</span> \(users)<span class="string">"</span>)
                <span class="keyword">if</span> !users.<span class="call">map</span>(\.<span class="property">id</span>).<span class="call">contains</span>(user.<span class="property">id</span>) {
                    userWasDeleted = <span class="keyword">true</span>
                }
            }
    }
}
</code></pre><p>Теперь решение работает и на iOS 14 и на iOS 15</p><p>Чтобы проверить свою теорию, что баг вызван вложенностью списков, следующий элемент ведет напрямую на дочернее вью, выбираем в основном списке элемент "Just user: Alexandr". Здесь кнопка Delete отработает как на iOS 14 так и на iOS 15, как с onChange, так и с onReceive.</p><ul><li>Нередко я встречал совет, что надо перебирать в списке не сами элементы, а индексы, мол это даст индекс из коробки, по которому потом можно доставать элемент или Binding.</li></ul><br/><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ListViewIndices: <span class="type">View</span> {
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">ForEach</span>(usersManager.<span class="property">users</span>.<span class="property">indices</span>, id: \.<span class="keyword">self</span>) { index <span class="keyword">in</span>
                <span class="type">NavigationLink</span>(
                    destination: <span class="type">UserView</span>(user: usersManager.<span class="property">users</span>[index]),
                    label: { <span class="type">Text</span>(usersManager.<span class="property">users</span>[index].name) }
                )
            }
            .<span class="call">onDelete</span> { indexSet <span class="keyword">in</span>
                usersManager.<span class="call">removeUsers</span>(indexSet: indexSet)
            }
        }
        .<span class="call">navigationBarTitle</span>(<span class="string">"Constants list"</span>, displayMode: .<span class="dotAccess">inline</span>)
        .<span class="call">navigationBarItems</span>(
            trailing: <span class="type">Button</span>(<span class="string">"Reload"</span>) {
                usersManager.<span class="call">getUsers</span>()
            }
        )
    }
}
</code></pre><p>Так вот, так делать не стоит. Таким образом мы говорим списку, что он должен различать элементы массива по их индексам, т.к. список теряет возможность по факту отличать элементы друг от друга. Выбираем в основном списке "Simple list without bindings, indices", заходим на первого юзера (Alexandr) и жмем Delete. В результате данные нашей View меняются на данные юзера Bob. В принципе это предсказуемо, т.к. как я уже говори идентификатором является сам индекс, число элементов изменилось, это вызвало перерисовку, элемент с индексом 0 был Alexandr стал Bob, SwiftUI посчитал, что элемент не удалился, а обновился. Более того XCode в зависимости от места использования может выдавать ворнинг про то, что мы используем ForEach не так как задумано</p><br/><pre><code><span class="type">ForEach</span>(_:content:) should only be used <span class="keyword">for</span> *constant* data. <span class="type">Instead</span> conform
data to <span class="type">Identifiable</span> or use <span class="type">ForEach</span>(_:id:content:) and provide an explicit id!
</code></pre><p>На этом мы закрываем секцию с View, которые инициализируются обычными переменными и переходим к разделу, где в дочерних View ожидаются @Bindable.</p><p>Начнем с истории. До Xcode 13 из коробки нельзя было получить для списка Binding значение. И люди шли на всевозможные ухищрения, от простейших типа</p><br/><pre><code><span class="type">ForEach</span>(<span class="type">Array</span>(array.<span class="call">enumerated</span>()), id: \.<span class="property">offset</span>) { index, element <span class="keyword">in</span>
</code></pre><p>или</p><br/><pre><code><span class="type">ForEach</span>(<span class="type">Array</span>(<span class="call">zip</span>(items.<span class="property">indices</span>, items)), id: \.<span class="number">0</span>) { index, item <span class="keyword">in</span>
</code></pre><p>до крутых навороченных решений (как я уже упоминал, одно из них приведено в ForEach+Binding.swift) Это решение позволяет писать вот так</p><br/><pre><code><span class="keyword">struct</span> ListViewBinding: <span class="type">View</span> {
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">ForEach</span>($usersManager.<span class="property">users</span>) { index, user <span class="keyword">in</span>
                <span class="type">NavigationLink</span>(
                    destination: <span class="type">UserViewWithBindingReadonly</span>(user: $usersManager.<span class="property">users</span>[index]),
                    label: { <span class="type">Text</span>(usersManager.<span class="property">users</span>[index].name) }
                )
            }
            .<span class="call">onDelete</span> { indexSet <span class="keyword">in</span>
                usersManager.<span class="call">removeUsers</span>(indexSet: indexSet)
            }
        }
    }
}
</code></pre><p>user внутри ForEach сразу будет типа Binding&lt;User&gt;</p><p>Круто? Круто, вот только падает иногда..</p><p>В секции "With bindings, readonly" выбираем пункт "List with custom bindings", выбираем последнего в списке юзера, заходим на него, жмем Delete. Crash. Ну и если удалять не последний элемент, а первый, то данные внутри открытой View заменятся данными следующего по списку элемента.<br>К счастью теперь у нас есть нативный подход</p><pre><code><span class="type">ForEach</span>($usersManager.<span class="property">users</span>) { $user <span class="keyword">in</span>
</code></pre><br/><pre><code><span class="keyword">enum</span> UserViewKind {
    <span class="keyword">case</span> useCache
    <span class="keyword">case</span> checkDeletion
    <span class="keyword">case</span> readonly
    <span class="keyword">case</span> editable
}
<span class="keyword">struct</span> ListWithBindingsXcode13: <span class="type">View</span> {
    <span class="keyword">let</span> userViewKind: <span class="type">UserViewKind</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">ForEach</span>($usersManager.<span class="property">users</span>) { $user <span class="keyword">in
                let</span> _ = <span class="call">print</span>(user)
                <span class="keyword">switch</span> userViewKind {
                    <span class="keyword">case</span> .<span class="dotAccess">useCache</span>:
                        <span class="type">NavigationLink</span>(
                            destination: <span class="type">UserViewWithBindingReadonlyCheckDeletionCached</span>(user: $user),
                            label: { <span class="type">Text</span>(<span class="string">"</span>\(user.<span class="property">name</span>)<span class="string">,</span> \(user.<span class="property">surname</span>)<span class="string">"</span>) }
                        )
                    <span class="keyword">case</span> .<span class="dotAccess">checkDeletion</span>:
                        <span class="type">NavigationLink</span>(
                            destination: <span class="type">UserViewWithBindingReadonlyCheckDeletion</span>(user: $user),
                            label: { <span class="type">Text</span>(<span class="string">"</span>\(user.<span class="property">name</span>)<span class="string">,</span> \(user.<span class="property">surname</span>)<span class="string">"</span>) }
                        )
                    <span class="keyword">case</span> .<span class="dotAccess">readonly</span>:
                        <span class="type">NavigationLink</span>(
                            destination: <span class="type">UserViewWithBindingReadonly</span>(user: $user),
                            label: { <span class="type">Text</span>(<span class="string">"</span>\(user.<span class="property">name</span>)<span class="string">,</span> \(user.<span class="property">surname</span>)<span class="string">"</span>) }
                        )
                    <span class="keyword">case</span> .<span class="dotAccess">editable</span>:
                        <span class="type">NavigationLink</span>(
                            destination: <span class="type">EditableUserInfoView</span>(user: $user),
                            label: { <span class="type">Text</span>(<span class="string">"</span>\(user.<span class="property">name</span>)<span class="string">,</span> \(user.<span class="property">surname</span>)<span class="string">"</span>) }
                        )
                }
            }
            .<span class="call">onDelete</span> { indexSet <span class="keyword">in</span>
                usersManager.<span class="call">removeUsers</span>(indexSet: indexSet)
            }
        }
    }
}
</code></pre><p>К сожалению это работает только в XCode 13. К счастью нет ограничения по iOS 15, есть обратная совместимость и это радует.<br>Проверяем работу удаления для пункта "List with Xcode 13 bindings, no check deletion"<br><br/></p><pre><code><span class="keyword">struct</span> UserViewWithBindingReadonly: <span class="type">View</span> {
    <span class="keyword">@Binding var</span> user: <span class="type">User</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">UserInfoView</span>(user: user)
            .<span class="call">withEditNavigationButtons</span>(user: user, usersManager: usersManager)
    }
}
</code></pre><p>Та же проблема, что и для "Simple list without bindings", если на iOS 15 удалять первый элемент в списке - вылетает на список, если другие - визуально ничего не происходит. На iOS 14 вообще визуальной реакции нет на удаления, ничего нового.</p><p>Проверяем работу удаления для пункта "List with Xcode 13 bindings, check deletion"<br><br/></p><pre><code><span class="keyword">struct</span> UserViewWithBindingReadonlyCheckDeletion: <span class="type">View</span> {
    <span class="keyword">@Binding var</span> user: <span class="type">User</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">@State private var</span> userWasDeleted: <span class="type">Bool</span> = <span class="keyword">false
    @Environment</span>(\.<span class="property">presentationMode</span>) <span class="keyword">var</span> presentationMode

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">UserInfoView</span>(user: user)
            .<span class="call">withEditNavigationButtons</span>(user: user, usersManager: usersManager)
            .<span class="call">alert</span>(isPresented: $userWasDeleted, content: {
                <span class="type">Alert</span>(
                    title: <span class="type">Text</span>(<span class="string">"User was deleted"</span>),
                    dismissButton: <span class="type">Alert</span>.<span class="type">Button</span>.<span class="call">cancel</span>(<span class="type">Text</span>(<span class="string">"OK"</span>), action: {
                        presentationMode.<span class="property">wrappedValue</span>.<span class="call">dismiss</span>()
                    })
                )
            })
            .<span class="call">onChange</span>(of: usersManager.<span class="property">users</span>) { users <span class="keyword">in</span>

                <span class="comment">// iOs 15 crash</span>

                <span class="call">print</span>(<span class="string">"UserViewWithBindingReadonlyCheckDeletion (onChange) users update:</span> \(users)<span class="string">, for user</span> \(user)<span class="string">"</span>)
                <span class="keyword">if</span> !users.<span class="call">map</span>(\.<span class="property">id</span>).<span class="call">contains</span>(user.<span class="property">id</span>) {
                    userWasDeleted = <span class="keyword">true</span>
                }
            }
<span class="comment">//            .onReceive(usersManager.$users) { users in
//                print("UserViewWithBindingReadonlyCheckDeletion (onReceive) users update: \(users)")
//                if !users.map(\.id).contains(user.id) {
//                    userWasDeleted = true
//                }
//            }</span>
    }
}
</code></pre><p>iOS 14: onChange не отрабатывает, фикс идентичен - использовать onReceive. Если попробовать с onChange перейти на navigationViewStyle(StackNavigationViewStyle()) - при удалении последнего элемента будет Crash как в кастомном решении</p><br/><p>iOS 15: onChange - удаление первого выбрасывает в список, удаление среднего ни к чему не приводит, удаление последнего - крэш, собрали все баги, флеш рояль ) onReceive - корректно отрабатывает во всех случаях.</p><br/><p>Чтобы уйти от крэшей можно попробовать воспользоваться системой кеша данных (ну или draft, кому как удобней). Подобное решение применяла Apple можно увидеть <a href="https://developer.apple.com/tutorials/swiftui/working-with-ui-controls">здесь</a></p><p>Основная идея - при показе View - копируем данные и работаем с ними, это позволит уйти от проблемы использования Binding для несуществующего элемента в массиве<br><br/></p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> UserViewWithBindingReadonlyCheckDeletionCached: <span class="type">View</span> {
    <span class="keyword">@Binding var</span> user: <span class="type">User</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>

    <span class="keyword">@State private var</span> userWasDeleted: <span class="type">Bool</span> = <span class="keyword">false
    @Environment</span>(\.<span class="property">presentationMode</span>) <span class="keyword">var</span> presentationMode

    <span class="keyword">@State private var</span> cachedUser: <span class="type">User</span> = <span class="type">User</span>(id: .<span class="keyword">init</span>(), name: <span class="string">""</span>, surname: <span class="string">""</span>, birthday: <span class="type">Date</span>(), views: <span class="number">0</span>)

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">UserInfoView</span>(user: user)
            .<span class="call">withEditNavigationButtons</span>(user: user, usersManager: usersManager)
            .<span class="call">onAppear</span> {
                cachedUser = user
            }
            .<span class="call">alert</span>(isPresented: $userWasDeleted, content: {
                <span class="type">Alert</span>(
                    title: <span class="type">Text</span>(<span class="string">"User was deleted"</span>),
                    dismissButton: <span class="type">Alert</span>.<span class="type">Button</span>.<span class="call">cancel</span>(<span class="type">Text</span>(<span class="string">"OK"</span>), action: {
                        presentationMode.<span class="property">wrappedValue</span>.<span class="call">dismiss</span>()
                    })
                )
            })
            .<span class="call">onChange</span>(of: usersManager.<span class="property">users</span>) { users <span class="keyword">in</span>
                <span class="call">print</span>(<span class="string">"UserViewWithBindingReadonlyCheckDeletionCached (onChange) users update:</span> \(users)<span class="string">, for user</span> \(cachedUser)<span class="string">"</span>)
                <span class="keyword">if</span> !users.<span class="call">map</span>(\.<span class="property">id</span>).<span class="call">contains</span>(cachedUser.<span class="property">id</span>) {
                    userWasDeleted = <span class="keyword">true</span>
                }
            }
<span class="comment">//            .onReceive(usersManager.$users) { users in
//                print("UserViewCheckDeletion (onReceive) users update: \(users)")
//                if !users.map(\.id).contains(cachedUser.id) {
//                    userWasDeleted = true
//                }
//            }</span>
    }
}
</code></pre><p>По сути главное что поменялось - добавилось<br><br/></p><pre><code>.<span class="call">onAppear</span> {
     cachedUser = user
}
</code></pre><br/><p>Это решение прекрасно отрабатывает с onChange на iOS 15. Но не работает на iOS 14 для удаления любых элементов кроме последнего. Для последнего просто падает )<br>Замена на onReceive выдает баг на обеих осях, связано с тем что мы инициализируем изначально</p><br/><pre><code><span class="keyword">@State private var</span> cachedUser: <span class="type">User</span> = <span class="type">User</span>(id: .<span class="keyword">init</span>(), name: <span class="string">""</span>, surname: <span class="string">""</span>, birthday: <span class="type">Date</span>(), views: <span class="number">0</span>)
</code></pre><p>А как я уже говорил, onReceive отрабатывает чаще, и на старте мы проверяем наличие этого дефолтного пустого юзера с usersManager.$users, и нам успевает показаться алерт что созданного на старте юзера с id: .init() не существует в массиве (что в принципе правда).</p><br/><p>Все примеры из секции "With bindings, readonly" передавали в дочерние view Binding&lt;User&gt;, хотя по факту не использовали возможностей по их обновлению напрямую, просто не хотел усложнять материал. Так что оставил это на сладкое</p><br/><p>Секция "With bindings, Editable", пункт "List with Xcode 13 bindings, editable"</p><br/><pre><code><span class="keyword">struct</span> EditableUserInfoView: <span class="type">View</span> {
    <span class="keyword">@Binding var</span> user: <span class="type">User</span>
    <span class="keyword">@EnvironmentObject var</span> usersManager: <span class="type">UsersManager</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">TextField</span>(<span class="string">"Name"</span>, text: $user.<span class="property">name</span>)
                .<span class="call">textFieldStyle</span>(<span class="type">RoundedBorderTextFieldStyle</span>())
            <span class="type">TextField</span>(<span class="string">"Surname"</span>, text: $user.<span class="property">surname</span>)
                .<span class="call">textFieldStyle</span>(<span class="type">RoundedBorderTextFieldStyle</span>())
        }
        .<span class="call">padding</span>()
        .<span class="call">withEditNavigationButtons</span>(user: user, usersManager: usersManager)
    }
}
</code></pre><p>В плане редактирования все работает как часы при любом варианте биндингов как через текстовые поля, так и через кнопку Update. В проекте я добавил обвязку через onReceive на проверку удаления, как единственно работающую на всех осях и для любого индекса удаляемого элемента.</p><br/><p>Вот такое вот выдалось приключение "на пару минут" как же сделать список с редактируемыми и удаляемыми в фоне элементами работающий одновременно и в iOS 14 и в iOS 15.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/working-with-data-in-swiftui</guid><title>Как работать с данными в SwiftUI</title><description>Как работать с данными в SwiftUI: @State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject. Разбираемся какие и когда стоит использовать.</description><link>https://sparklone.github.io/articles/working-with-data-in-swiftui</link><pubDate>Sun, 27 Jun 2021 15:30:00 +0300</pubDate><content:encoded><![CDATA[<h1>Как работать с данными в SwiftUI</h1><p>SwiftUI богат обертками для работы с данными. Подробней ознакомиться с тем, что такое Property Wrapper'ы (обертки) и с чем их едят можно в моей предыдущей статье <a href="https://sparklone.github.io/articles/property-wrappers-in-swift/">Property Wrappers в Swift</a></p><p>Так что в этой статье мы рассмотрим практическое применение существующих оберток для работы с данными в SwiftUI.</p><p>Основной момент: если меняется значение внутри переменной любой из указанных оберток, и эта переменная используется внутри переменной body, - переменная body будет вычислена повторно, таким образом View обновится (перерисуется).</p><p>Итак, первой оберткой является State.</p><h2>@State</h2><p>Исходя из документации Apple <a href="https://developer.apple.com/documentation/swiftui/state">State</a> необходимо использовать для хранения данных конкретной View. <a href="https://developer.apple.com/documentation/swiftui/state-and-data-flow">Здесь</a> Apple советует в @State хранить именно UI состояние, а не бизнес логику. <em>"Manage transient UI state locally within a view by wrapping value types as State properties."</em></p><p>Более того очень важно работать с этой переменной только внутри View, где она была объявлена, причем только из переменной body, или из методов которые вызываются из переменной body. Поэтому всегда стоит @State объявлять приватной переменной.</p><p><em>"You should only access a state property from inside the view’s body, or from methods called by it. For this reason, declare your state properties as private, to prevent clients of your view from accessing them. It is safe to mutate state properties from any thread."</em></p><p>Приведу простой пример использования @State, он искусственный (как раз View-счетчик обычно полезно инициализировать значениями извне), но с ним проще играться.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> SimplestState: <span class="type">View</span> {
    <span class="keyword">@State private var</span> counter = <span class="number">0</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"counter:</span> \(counter)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">HStack</span>(spacing: <span class="number">20</span>) {
                <span class="type">Button</span>(<span class="string">"Increase"</span>) {
                    counter += <span class="number">1</span>
                }

                <span class="type">Button</span>(<span class="string">"Decrease"</span>) {
                    counter = <span class="call">max</span>(<span class="number">0</span>, counter - <span class="number">1</span>)
                }
                .<span class="call">disabled</span>(counter == <span class="number">0</span>)
            }
        }
    }
}

<span class="keyword">struct</span> SimplestState_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">SimplestState</span>()
    }
}

</code></pre><p>Хотел бы обратить внимание еще на одну вещь. Хранить в @State стоит только простые типы (Int, String, Bool) ну или в крайнем случае - структуры, но ни в коем случае не классы. Почему? Ну просто потому что с классами State не будет работать.</p><p>Об этом косвенно упоминается в документации фразой <em>"When the state value changes, the view invalidates its appearance and recomputes the body."</em> Подозреваю, что если бы был протокол, который ограничивает что его может реализовать только структура, но не класс - данная обертка бы его использовала (по аналогии с AnyObject для классов).</p><p>Если мы используем @State для структуры, то любое изменение любого ее поля по факту "под капотом" приведет к созданию новой копии структуры, которая перепишет значение в State переменной, что вызовет перерисовку View.</p><p>В случае же класса этого не произойдет. Но не стоит мне верить на слово, show me the code!</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> Datas {
<span class="comment">//class Datas {</span>

    <span class="keyword">var</span> int: <span class="type">Int</span>
    <span class="keyword">var</span> string: <span class="type">String</span>

    <span class="keyword">internal init</span>(int: <span class="type">Int</span>, string: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">int</span> = int
        <span class="keyword">self</span>.<span class="property">string</span> = string
    }

}

<span class="keyword">struct</span> StateExample: <span class="type">View</span> {
    <span class="keyword">@State private var</span> datas = <span class="type">Datas</span>(int: <span class="number">1</span>, string: <span class="string">"String"</span>)
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">14</span>) {
            <span class="type">Text</span>(<span class="string">"datas int:</span> \(datas.<span class="property">int</span>)<span class="string">"</span>)
            <span class="type">Button</span>(<span class="string">"Change int"</span>) {
                datas.<span class="property">int</span> += <span class="number">1</span>
            }

            <span class="type">Text</span>(<span class="string">"datas string:</span> \(datas.<span class="property">string</span>)<span class="string">"</span>)
            <span class="type">Button</span>(<span class="string">"Change string"</span>) {
                datas.<span class="property">string</span> += <span class="string">"."</span>
            }
        }
    }
}

<span class="keyword">struct</span> StateExample_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">StateExample</span>()
    }
}
</code></pre><p>Нажатие на кнопки приводит к ожидаемым изменениям только если Datas - struct, если же Datas сделать class - изменение полей класса не приводит к изменению всей переменной datas, и код стоящий за propertyWrapper @State не подхватит изменение объекта и не выполнит повторное вычисление переменной body.</p><h4>Таким образом используем @State:</h4><br/><ul><li>для того чтобы хранить внутреннее состояние View, которое не надо сохранять между сессиями работы приложения.</li></ul><p>К примеру у View которая является кастомной кнопкой можно добавить флаг нажата кнопка или нет. Подразумевая, что если мы создаем кнопку - она всегда в значении по умолчанию. Или для id активного элемент списка. Обычно при заходе на экран со списком ни один элемент не выделен и это не задается снаружи.</p><ul><li>так же очень часто @State используют как черновик, во время прототипирования экрана, чтобы впоследствии перенести переменную в тот же ObservedObject.</li></ul><h2>@Binding</h2><p>Со @State вроде все понятно, но как передавать значение переменных объявленных как State внутренним компонентам, чтобы дети могли их изменять и чтобы изменения отражались и в родительской View? (мы же за модульную структуру).</p><p>Для этого и была создана обертка <a href="https://developer.apple.com/documentation/swiftui/binding">@Binding</a>, чтобы установить двустороннюю связь в плане данных состояния View между родительской View и ее ребенком.</p><p>Заглянем в документацию, или чтобы ускорить процесс, можно воспользоваться инструментом Jump to Definition в Xcode. Если навести курсор мыши над словом @State в Xcode, нажать на клавиатуре ⌃ + ⌘ и нажать левую кнопку (по факту выполнить Jump to Definition), то мы увидим документацию по State прям внутри Xcode. Вообще рекомендую почаще заглядывать в документацию.</p><p>Благодаря этой документации можно убедиться, что projectedValue имеет тип <code>Binding&lt;Value&gt;</code> (доп информацию по projectedValue можно получить из прошлой <a href="https://sparklone.github.io/articles/property-wrappers-in-swift/">статьи</a> )</p><p>В приведенном ниже примере read/write доступ имеют как parent view (BindingExample), она отображает имя и может его обнулить с помощью кнопки Reset, так и child view ChildTextControl, которая в свою очередь делегирует изменение имени в системный контрол TextField</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> BindingExample: <span class="type">View</span> {
    <span class="keyword">@State private var</span> name = <span class="string">""</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">14</span>) {
            <span class="type">Text</span>(<span class="string">"Current name:</span> \(name)<span class="string">"</span>)
            
            <span class="type">Button</span>(<span class="string">"Reset"</span>) {
                name = <span class="string">""</span>
            }.<span class="call">disabled</span>(name.<span class="property">count</span> == <span class="number">0</span>)

            <span class="type">ChildTextControl</span>(text: $name)

            <span class="type">Spacer</span>()
        }.<span class="call">padding</span>([.<span class="dotAccess">top</span>, .<span class="dotAccess">bottom</span>])
    }
}

<span class="keyword">struct</span> ChildTextControl: <span class="type">View</span> {

    <span class="keyword">@Binding var</span> text: <span class="type">String</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">TextField</span>(<span class="string">"Enter name"</span>, text: $text)
            .<span class="call">padding</span>()
    }
}

<span class="keyword">struct</span> BindingExample_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">BindingExample</span>()
    }
}
</code></pre><p>В примере можно увидеть что ChildTextController ожидает в конструкторе <code></code><code>@Binding var text: String</code><code></code> а мы передаем <code></code><code>$name</code><code></code>.</p><p>В документации можно узнать, что подставляя символ $ перед State переменной мы по факту получаем projectedValue у State, а для State projectedValue имеет тип <code></code><code>Binding&lt;Value&gt;</code><code></code>, т.е. $name и есть Binding</p><p>И вновь таки применив Jump to Definition уже на @Binding мы можем увидеть, что конструктор структуры Binding в качестве параметров принимает замыкания get/set</p><pre><code><span class="keyword">public init</span>(get: <span class="keyword">@escaping</span> () -&gt; <span class="type">Value</span>, set: <span class="keyword">@escaping</span> (<span class="type">Value</span>) -&gt; <span class="type">Void</span>)
</code></pre><p>Таким образом Binding - это средство, которое позволяет работать с value типами как с reference. Ведь если мы передадим Int из одной View в другую - произойдет ее копирование и изменения в parent не будут отражаться в child, впрочем как и наоборот. А Binding - это фасад, который скрывает что под капотом он несет не сами данные а функции позволяющие читать/писать в оригинальное хранилище данных где лежит тот же наш Int.</p><p>Так же из документации можно подсмотреть, что Binding можно инициализировать константой, и полезно это при использовании Preview</p><pre><code><span class="keyword">public static func</span> constant(<span class="keyword">_</span> value: <span class="type">Value</span>) -&gt; <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt;
</code></pre><p>К примеру Preview к нашему компоненту ChildTextControl мог бы выглядеть так:</p><pre><code><span class="keyword">struct</span> ChildTextControl_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ChildTextControl</span>(text: .<span class="call">constant</span>(<span class="string">"test"</span>))
    }
}
</code></pre><p>Ну и если @State переменная хранит какую то структуру со своими полями (как вышеприведенная struct Datas), то можно передавать не всю ее ребенку а только нужное поле с помощью того же $ с указанием нужного поля</p><pre><code><span class="type">ChildTextControl</span>(text: $datas.<span class="property">string</span>)

</code></pre><h4>Таким образом область применения @Binding:</h4><br/><ul><li>передать доступ переменных обозначенных как @State / @Published внутрь дочерних компонентов</li></ul><h2>Протокол ObservableObject</h2><p>Обертки @StateObject, @EnvironmentObject, @ObservedObject будут работать с классами реализующими протокол ObservableObject, вот его определение</p><pre><code><span class="keyword">@available</span>(iOS <span class="number">13.0</span>, macOS <span class="number">10.15</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">6.0</span>, *)
<span class="keyword">public protocol</span> ObservableObject : <span class="type">AnyObject</span> {

    <span class="comment">/// The type of publisher that emits before the object has changed.</span>
    <span class="keyword">associatedtype</span> ObjectWillChangePublisher : <span class="type">Publisher</span> = <span class="type">ObservableObjectPublisher</span> <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">ObjectWillChangePublisher</span>.<span class="type">Failure</span> == <span class="type">Never</span>

    <span class="comment">/// A publisher that emits before the object has changed.</span>
    <span class="keyword">var</span> objectWillChange: <span class="type">Self</span>.<span class="type">ObjectWillChangePublisher</span> { <span class="keyword">get</span> }
}
</code></pre><p>Из определения протокола видно, что реализовать его могут только классы, по сути классы реализующие этот протокол будут являться полноценными контейнерами для данных, хранить данные бизнес логики, а не внутреннее состояние View (как @State).</p><p>И работать можно будет с каждым свойством отдельно за счет того, что у каждого свойства мы будем проставлять @Published, что под капотом использует фреймворк Combine. Как указано в документации, для ObservableObject определено свойство objectWillChange, которое будет генерировать событие <strong>перед</strong> каждым изменение свойств помеченных как @Published.</p><p>И если бы мы использовали ObservableObject напрямую, то код мог бы выглядеть как то так:</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">import</span> Combine

<span class="keyword">var</span> cancellables = <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()

<span class="keyword">class</span> Product: <span class="type">ObservableObject</span> {
    <span class="keyword">@Published var</span> title: <span class="type">String</span>
    <span class="keyword">@Published var</span> price: <span class="type">Double</span>

    <span class="keyword">init</span>(title: <span class="type">String</span>, price: <span class="type">Double</span>) {
        <span class="keyword">self</span>.<span class="property">title</span> = title
        <span class="keyword">self</span>.<span class="property">price</span> = price
    }

    <span class="keyword">func</span> increasePrice(by value: <span class="type">Double</span>) -&gt; <span class="type">Double</span> {
        price += value
        <span class="keyword">return</span> price
    }

}

<span class="keyword">let</span> product = <span class="type">Product</span>(title: <span class="string">"Phone"</span>, price: <span class="number">100.00</span>)
product.<span class="property">objectWillChange</span>
    .<span class="call">sink</span> { <span class="keyword">_ in</span>
        <span class="call">print</span>(<span class="string">"price '</span>\(product.<span class="property">price</span>)<span class="string">' will change"</span>)
    }
    .<span class="call">store</span>(in: &amp;cancellables)

<span class="call">print</span>(product.<span class="call">increasePrice</span>(by: <span class="number">50</span>))
</code></pre><p>Это выведет в консоль 100, а не 150, на то и willChange а не didChange</p><pre><code>price '<span class="number">100.0</span>' will change
<span class="number">150.0</span>
</code></pre><p>Мы так же можем с помощью Combine подписаться и на изменение конкретного поля</p><pre><code>product.$price.<span class="call">sink</span> { value <span class="keyword">in</span>
    <span class="call">print</span>(<span class="string">"direct $price access: price '</span>\(product.<span class="property">price</span>)<span class="string">' will change"</span>)
}.<span class="call">store</span>(in: &amp;cancellables)
</code></pre><p>Если вставить этот код перед print(product...), то в консоли будет</p><pre><code>direct $price access: price '<span class="number">100.0</span>' will change
price '<span class="number">100.0</span>' will change
direct $price access: price '<span class="number">100.0</span>' will change
<span class="number">150.0</span>
</code></pre><p>т.к. на момент подписки на $price там уже было значение - мы тут же его получаем, а следующий print из <code></code><code>product.$price.sink</code><code></code> отработает уже во время увеличения price. Убедиться в этом можно закомментировав <code></code><code>print(product.increasePrice(by: 50))</code><code></code> таким образом пусть мы вообще не изменяем объект product - все равно подписка <code></code><code>product.$price.sink</code><code></code> отработает, напечатав при этом в консоль одну строку:</p><pre><code>direct $price access: price '<span class="number">100.0</span>' will change
</code></pre><p>В принципе нам никто не запрещает в классе реализующем ObservableObject самим генерировать новые события в objectWillChange (хоть по таймеру) при необходимости.</p><p>Но мы в основном будем сталкиваться с ObservableObject именно в связке с SwiftUI, и мы будем напрямую работать со свойствами объектов реализующих ObservableObject, а события из objectWillChange будет перехватывать сам SwiftUI для того чтобы знать, что надо перерисовать View. По всей видимости именно для оптимизации эффективности генерируется willSet, а не didSet, т.к. это позволяет накапливать изменения и обновлять View реже.</p><p>Что же, рассмотрим первую обертку работающую с ObservableObject - ObservedObject.</p><h2>@ObservedObject</h2><p>Документация довольно немногословна, и говорит, что <a href="https://developer.apple.com/documentation/swiftui/observedobject">@ObservedObject</a> это обертка, которая подписывается на объект ObservableObject и обновляет View, когда данные объекта меняются. По сути это мост между данными хранящимися в ObservableObject и нашими View.</p><p>Кстати при выходе SwiftUI нам была доступна только эта обертка, @StateObject была добавлена позже (в так называемом SwiftUI 2.0, представленном на WWDC 2020), давайте на этом примере поймем почему пришлось добавить еще одну обертку.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">class</span> AppState: <span class="type">ObservableObject</span> {
    <span class="keyword">@Published var</span> counter: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">struct</span> ObservedObjectExample: <span class="type">View</span> {
    <span class="keyword">@State private var</span> mainCounter = <span class="number">0</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Main counter:</span> \(mainCounter)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                mainCounter += <span class="number">1</span>
            }

            <span class="type">Divider</span>().<span class="call">padding</span>()

            <span class="type">CounterView</span>()
        }.<span class="call">padding</span>()
    }
}

<span class="keyword">struct</span> CounterView: <span class="type">View</span> {
    <span class="keyword">@ObservedObject var</span> appState = <span class="type">AppState</span>()

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Child counter:</span> \(appState.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">HStack</span>(spacing: <span class="number">20</span>) {
                <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                    appState.<span class="property">counter</span> += <span class="number">1</span>
                }
                
                <span class="type">Button</span>(<span class="string">"Decrease"</span>) {
                    appState.<span class="property">counter</span> = <span class="call">max</span>(<span class="number">0</span>, appState.<span class="property">counter</span> - <span class="number">1</span>)
                }
                .<span class="call">disabled</span>(appState.<span class="property">counter</span> == <span class="number">0</span>)
            }
        }
    }
}

<span class="keyword">struct</span> ObservedObjectExample_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ObservedObjectExample</span>()
    }
}
</code></pre><p>Во View верхнего уровня ObservedObjectExample мы отображаем как @State счетчик mainCounter (в Text), так и ребенка CounterView, у которого внутри создается переменная типа AppState с указанной оберткой @ObservedObject</p><p>На первый взгляд проблем нет никаких, мы можем нажать кнопку "Increase main" для Main counter и это честно увеличит <code></code><code>@State private var mainCounter</code><code></code>, обновив ObservedObjectExample. Мы можем нажать Increase/Decrease для ребенка CounterView, что изменит данные в переменной AppState и SwiftUI честно перерисует CounterView. Где подвох?</p><p>А подвох в том, что если еще раз нажать "Increase main" для Main counter, счетчик Child counter обнулится.</p><p>Почему так случилось? На самом деле все просто, при нажатии на "Increase main" меняется mainCounter, что вызывает пересчет переменной body для ObservedObjectExample, что в свою очередь вызывает пересоздание CounterView. А при повторном создании CounterView у нас вновь инициализируется переменная appState со счетчиком counter = 0. Если не ожидать этого - неожиданное пересоздание переменной может стать очень неприятным сюрпризом.</p><p>Таким образом сферой применения @ObservedObject можно было бы считать:</p><ul><li>если вам нужно, чтобы происходило пересоздание состояния. Хотя тяжело представить зачем такое может быть нужно, т.к. одно дело когда это ожидаемое поведение (переход со списка List в DetailView), а другое дело приведенный выше пример, когда дочерний компонент неожиданно сбрасывает свое состояние.</li></ul><ul><li>если вы уверены, что переменная никогда не будет уничтожена, создаем к примеру на старте приложения внутри того же WindowGroup</li></ul><br/><p>Но как будет пояснено в разделе с @StateObject даже это не стоит делать.</p><h4>Остается одно применение @ObservedObject:</h4><br/><ul><li>если вам надо уже созданную переменную класса реализующего ObservableObject передать вниз по иерархии.</li></ul><h2>@StateObject</h2><p>После WWDC 2020 нам добавили еще одну обертку - <a href="https://developer.apple.com/documentation/swiftui/stateobject">@StateObject</a>, спасителя от пересоздания переменной при перерисовке View.</p><p>Для того, чтобы починить баг со сбросом состояния дочерней View при увеличения счетчика родительской - достаточно в CounterView сменить @ObservedObject на @StateObject.</p><p>Вернемся к теории, в документации для <strong>@StateObject</strong> написано "A property wrapper type that <strong>instantiates</strong> an observable object.", в то время как для <strong>@ObservedObject</strong> "A property wrapper type that <strong>subscribes</strong> to an observable object and invalidates a view whenever the observable object changes."</p><p>Таким образом Apple прямо говорит - не стоит создавать самим ObservedObject внутри View которое будет его использовать, создавать нужно только StateObject, а уже в дочерних View определять переменную как @ObservedObject.</p><p>Проследить путь appState и убедиться, что все причастные View работают с одним и тем же объектом appState можно в этом примере</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">class</span> AppState: <span class="type">ObservableObject</span> {
    <span class="keyword">@Published var</span> counter: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">struct</span> StateObjectTestView: <span class="type">View</span> {
    <span class="keyword">@StateObject private var</span> appState = <span class="type">AppState</span>()
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Observed Object"</span>)) {
                    <span class="type">NavigationLink</span>(
                        destination: <span class="type">NestedObservedObjectExample</span>(state: appState),
                        label: {
                            <span class="type">Text</span>(<span class="string">"Nested ObservedObject Example"</span>)
                        })
                }
            }
        }
    }
}

<span class="keyword">struct</span> NestedObservedObjectExample: <span class="type">View</span> {
    <span class="keyword">@ObservedObject var</span> state: <span class="type">AppState</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Main counter:</span> \(state.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                state.<span class="property">counter</span> += <span class="number">1</span>
            }

            <span class="type">Divider</span>().<span class="call">padding</span>()

            <span class="type">NestedCounterView</span>(appState: state)
        }.<span class="call">padding</span>()
    }
}

<span class="keyword">struct</span> NestedCounterView: <span class="type">View</span> {
    <span class="keyword">@ObservedObject var</span> appState: <span class="type">AppState</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>, spacing: <span class="number">20</span>) {
            <span class="type">Text</span>(<span class="string">"Child counter:</span> \(appState.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">HStack</span>(spacing: <span class="number">20</span>) {
                <span class="type">Button</span>(<span class="string">"Increase"</span>) {
                    appState.<span class="property">counter</span> += <span class="number">1</span>
                }

                <span class="type">Button</span>(<span class="string">"Decrease"</span>) {
                    appState.<span class="property">counter</span> = <span class="call">max</span>(<span class="number">0</span>, appState.<span class="property">counter</span> - <span class="number">1</span>)
                }
                .<span class="call">disabled</span>(appState.<span class="property">counter</span> == <span class="number">0</span>)
            }
        }
    }
}

<span class="keyword">struct</span> StateObjectTestView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">StateObjectTestView</span>()
    }
}
</code></pre><p>Видно, что в корневой View (а можно было и в WindowGroup) мы определяем переменную как @StateObject, а во всех дочерних как @ObservedObject, и где бы мы не меняли appState.counter - данные будут обновлены во всех View.</p><p>Важно отметить, что @StateObject привязывается к конкретному экземпляру View, не к типу View.</p><h4>Область применения @StateObject:</h4><br/><ul><li>создавать объекты с данными внутри View, будучи уверенным, что они не обнулятся при перерисовке этого View. И это важный момент, если же пересоздастся родительская View (вернулись по навигационному стеку назад и зашли снова на родительскую View к примеру), то уже пересоздадутся и дочерние View, соответственно пересоздадутся и дочерние переменные, хоть они и @StateObject. Т.е. не стоит думать, что если мы пометили переменную как @StateObject, то она вообще никогда не пересоздастся, это работает только в рамках пересоздания внутри body родительской View.</li></ul><h2>@EnvironmentObject</h2><p>Практически Dependency Injection из коробки. По сути мало чем отличается от ObservedObject, в том смысле, что parent создает переменную, а дочерняя View получает к этой переменной доступ. Разница в том, что прикрепляя эту переменную к родительской View - все дети, и дети детей и т.д получают к ней доступ. Особенно это удобно, если эта переменная нужна только на самых нижних уровнях, т.к. нет необходимости прокидывать через все View посредники. Есть подводный камень, не всегда ясно, будет ли передан environmentObject для дочерних View созданных посредтвом alert, sheet, navigationLink. На WWDC 2021 разработчики apple рекомендовали для этих случаев проставлять вручную envirionmentObject</p><p>Original Question: I’ve had several intermittent crashes from environment objects being nil when I pass them to a sheet or NavigationLink. It’s tricky to replicate due to being intermittent and I usually work around it by architecting my code differently to avoid passing environment objects. Do you know of reasons this might happen? All I can think of is that the views that originate the environmentObject further up the view hierarchy are being taken out of memory. Thanks for any help you can provide!</p><p>Answer (engineer #1): NavigationLink by design doesn’t flow EnvironmentObjects through to its destination as it’s unclear where the environmentObject should be inherited from. I suspect this might what’s causing your issue. In order to get the behavior you expect, you’ll have to explicitly pass the environmentObject through at that point.</p><p>Answer (engineer #2):You can also apply the environmentObject to the NavigationView itself, which will make it available to all pushed content.</p><pre><code>

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@StateObject private var</span> appState = <span class="type">AppState</span>()
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
            	...
            	<span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Environment Object"</span>)) {
                    <span class="type">NavigationLink</span>(
                        destination: <span class="type">EnvironmentObjectExample</span>()
                            .<span class="call">environmentObject</span>(appState),
                        label: {
                            <span class="type">Text</span>(<span class="string">"EnvironmentObject Example"</span>)
                        })
                }
            ...
}     



<span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> EnvironmentObjectExample: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Main"</span>)
            <span class="type">Child1EnvironmentObjectExample</span>()
        }
    }
}

<span class="keyword">struct</span> Child1EnvironmentObjectExample: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Child1"</span>)
            <span class="type">Child2EnvironmentObjectExample</span>()
        }
    }
}

<span class="keyword">struct</span> Child2EnvironmentObjectExample: <span class="type">View</span> {
    <span class="keyword">@EnvironmentObject var</span> appState: <span class="type">AppState</span>
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Child2"</span>)
            <span class="type">Text</span>(<span class="string">"Environment counter:</span> \(appState.<span class="property">counter</span>)<span class="string">"</span>)
                .<span class="call">font</span>(.<span class="dotAccess">title</span>)
            <span class="type">Button</span>(<span class="string">"Increase main"</span>) {
                appState.<span class="property">counter</span> += <span class="number">1</span>
            }
        }
    }
}
</code></pre><p>Из примера можно извлечь следующее:</p><ul><li>чтобы проставить environmentObject нужно для корневой View проставить .environmentObject(&lt;object&gt;) <br/></li></ul><ul><li>получать доступ можно в любой дочернeй View на любой глубине с помощью</li></ul><br/><pre><code><span class="keyword">@EnvironmentObject var</span> varName: <span class="type">Type</span> 
</code></pre><ul><li>создавать объекты для environment так же стоит с помощью @StateObject. Но нужно быть очень аккуратным, т.к. если мы забыли проставить <code>.environmentObject(object)</code> - при попытке открыть View использующее отсутствующий EnvironmentObject - вылетит Fatal error.</li></ul><br/><p>Так же естественным ограничением является то, что можно положить в Environment только один объект определенного типа для конкретной иерархии View, т.к. доступ идет по типу, а не по имени (.environmentObject(&lt;object&gt;))</p><h4>Область применения @EnvironmentObject:</h4><br/><ul><li>если объект используется детьми View и нужен всего 1 объект данного типа, особенно если объект нужен не всем View в цепочке создания, а где то глубоко внизу в цепочке созданных View, чтобы не передавать постоянно ObservedObject явно от родителя к ребенку, коль большинству View это все равно это не нужно.</li></ul><br/><h4>Про остальные обертки вкратце:</h4><br/><p>Есть так же обертки для частных случаев. Подробно я их разбирать не буду, просто упомяну</p><ul><li>@AppStorage, по сути прокси для UserDefaults</li><li>@FetchRequest, позволяет получить доступ к CoreData объектам из View</li><li>@SceneStorage, в основном используется для state restoration, чтобы после перезапуска приложения мы могли показать приложение в том виде в котором оно находилось перед закрытием (положение, позиция внутри экрана и т.д.)</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/property-wrappers-in-swift</guid><title>Property Wrappers в Swift</title><description>Разбираемся что таке Property Wrappers в Swift, как они устроены, какие есть возможности и подводные камни.</description><link>https://sparklone.github.io/articles/property-wrappers-in-swift</link><pubDate>Mon, 16 Nov 2020 02:00:00 +0300</pubDate><content:encoded><![CDATA[<h1>Property Wrappers в Swift</h1><p>В рамках предложения <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md">SE-0258 Property Wrappers</a> в Swift добавили возможность к свойствам добавлять обертки. В основном это было сделано для SwiftUI. Чтобы было проще работать с данными добавили <strong>@State</strong>, <strong>@Binding</strong>, <strong>@ObservedObject</strong> и т.д.</p><p>Я бы не сказал, что Property Wrappers очень сложны для понимания, но стоит в них разобраться получше, т.к. есть и нюансы. Итак, что такое property wrapper? Из самого названия можно догадаться, что это обертка над свойством, которая добавляет логику к этому свойству.</p><p>Перед тем как углубляться в более сложные примеры давайте создадим простейшую обертку-пустышку, которая по сути ничего не делает, просто хранит значение. Исходя из <strong>SE-0258</strong>, чтобы создать свою обертку необходимо</p><ol><li>чтобы перед типом стоял атрибут <strong>@propertyWrapper</strong></li><li>тип обязан содержать переменную <strong>wrappedValue</strong> с уровнем доступа не ниже, чем у самого типа</li></ol><br/><p>Итого простейший пример будет выглядеть так:</p><pre><code><span class="keyword">@propertyWrapper
struct</span> Simplest&lt;T&gt; {
    <span class="keyword">var</span> wrappedValue: <span class="type">T</span>
}
</code></pre><p>Попробуем применить нашу обертку:</p><pre><code><span class="keyword">struct</span> TestSimplest {
    <span class="keyword">@Simplest var</span> value: <span class="type">String</span>
}

<span class="keyword">let</span> simplest = <span class="type">TestSimplest</span>(value: <span class="string">"test"</span>)
<span class="call">print</span>(simplest.<span class="property">value</span>)

</code></pre><p>В консоли будет выведено: test</p><p>Но если внимательно изучить proposal, то мы обнаружим как внутри объекта раскрываются property wrapper'ы на самом деле</p><pre><code><span class="keyword">struct</span> TestSimplest {
    <span class="keyword">@Simplest var</span> value: <span class="type">String</span>

    <span class="comment">// будет развернуто в</span> 
    <span class="keyword">private var</span> _value: <span class="type">Simplest</span>
    <span class="keyword">var</span> value: <span class="type">String</span> { <span class="comment">/* доступ через _value.wrappedValue */</span> }
}
</code></pre><p>За счет приватности снаружи мы не можем получить доступ к wrapper'у <strong>print(simplest._value)</strong> выдаст ошибку</p><p>Но изнутри типа мы вполне можем получить доступ к самому wrapper'у напрямую</p><pre><code><span class="keyword">extension</span> <span class="type">TestSimplest</span> {
    <span class="keyword">func</span> describe() {
        <span class="call">print</span>(<span class="string">"value:</span> \(value) <span class="string">type:</span> \(<span class="call">type</span>(of: value))<span class="string">"</span>)
        <span class="call">print</span>(<span class="string">"_value:</span> \(_value) <span class="string">type:</span> \(<span class="call">type</span>(of: _value))<span class="string">"</span>)
        <span class="call">print</span>(<span class="string">"_value.wrappedValue:</span> \(_value.<span class="property">wrappedValue</span>) <span class="string">type:</span> \(<span class="call">type</span>(of: _value.<span class="property">wrappedValue</span>))<span class="string">"</span>)
    }
}

<span class="keyword">let</span> simplest = <span class="type">TestSimplest</span>(value: <span class="string">"test"</span>)
simplest.<span class="call">describe</span>()
</code></pre><p>Это выведет</p><pre><code>value: test type: <span class="type">String</span>
_value: <span class="type">Simplest</span>&lt;<span class="type">String</span>&gt;(wrappedValue: <span class="string">"test"</span>) type: <span class="type">Simplest</span>&lt;<span class="type">String</span>&gt;
_value.<span class="property">wrappedValue</span>: test type: <span class="type">String</span>
</code></pre><p>что подтверждает, что _value - реальная обертка, а value == _value.wrappedValue == String</p><p>Разобравшись с простейшим примером попробуем создать что то чуть более полезное, к примеру обертку для целых чисел со следующей логикой - если присваивается отрицательное число - делаем его положительным, по сути обертка над функцией <strong>abs</strong></p><pre><code><span class="keyword">@propertyWrapper
struct</span> Abs {
    <span class="keyword">private var</span> value: <span class="type">Int</span> = <span class="number">0</span>

    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> {
        <span class="keyword">get</span> { value }
        <span class="keyword">set</span> {
            value = <span class="call">abs</span>(newValue)
        }
    }

    <span class="keyword">init</span>(wrappedValue: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">wrappedValue</span> = wrappedValue
    }
}

<span class="keyword">struct</span> TestAbs {
    <span class="keyword">@Abs var</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">var</span> testAbs = <span class="type">TestAbs</span>(value: -<span class="number">10</span>)
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = <span class="number">20</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = -<span class="number">30</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
</code></pre><p>В консоли будет</p><pre><code><span class="number">10
20
30</span>
</code></pre><p>Логику мы поместили в set для <strong>wrappedValue</strong>, в совокупности с инициализатором в котором мы присваиваем изначальное значение в свойство <strong>wrappedValue</strong> это позволяет нам получить нужное поведение как при инициализации переменной с оберткой, так и при дальнейшем ее изменении, в результате отрицательного числа не может быть в value в принципе. Обращаю внимание, что важно, чтобы в инициализаторе первым параметром шел параметр с именем wrappedValue, это позволяет swift'у под капотом позволять вот такие вот присваивания, когда мы в переменную помеченную оберткой можем присвоить значение того типа, который она содержит</p><pre><code><span class="keyword">@Abs var</span> value: <span class="type">Int</span> = <span class="number">0</span>
</code></pre><p>если мы поменяем к примеру на</p><pre><code><span class="keyword">init</span>(custom: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">wrappedValue</span> = custom
}
</code></pre><p>это уже не будет работать</p><p>Стоит отметить, что т.к. по факту реализуют <strong>@propertyWrapper</strong> самые обычные типы, мы можем параметризовать обертки.</p><p>К примеру создадим обертку Uppercased, которая принимает на вход так же число символов, которое необходимо конвертировать в upper case с начала строки.</p><pre><code><span class="keyword">@propertyWrapper
struct</span> Uppercased {
    <span class="keyword">private var</span> count: <span class="type">Int</span>
    <span class="keyword">private var</span> value: <span class="type">String</span> = <span class="string">""</span>

    <span class="keyword">var</span> wrappedValue: <span class="type">String</span> {
        <span class="keyword">get</span> { value }
        <span class="keyword">set</span> {
            <span class="keyword">let</span> uppercased = <span class="type">String</span>(newValue.<span class="call">prefix</span>(count)).<span class="call">uppercased</span>()
            value = uppercased
            <span class="keyword">guard let</span> from = newValue.<span class="call">index</span>(newValue.<span class="property">startIndex</span>, offsetBy: count, limitedBy: newValue.<span class="property">endIndex</span>) <span class="keyword">else</span> { <span class="keyword">return</span> }
            value += newValue.<span class="call">suffix</span>(from: from)
        }
    }

    <span class="keyword">init</span>(wrappedValue: <span class="type">String</span>, count: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">count</span> = count
        <span class="keyword">self</span>.<span class="property">wrappedValue</span> = wrappedValue
    }

}

<span class="keyword">struct</span> TestUppercased {
    <span class="keyword">@Uppercased</span>(count: <span class="number">5</span>) <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span>
}

<span class="keyword">var</span> testAbs = <span class="type">TestUppercased</span>(value: <span class="string">"hello world"</span>)
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = <span class="string">"another example"</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
testAbs.<span class="property">value</span> = <span class="string">"abc"</span>
<span class="call">print</span>(testAbs.<span class="property">value</span>)
</code></pre><p>В консоли будет</p><pre><code><span class="type">HELLO</span> world
<span class="type">ANOTHer</span> example
<span class="type">ABC</span>
</code></pre><p>Так же хотел бы обратить внимание на "магию", этот пример не будет компилироваться, если в <strong>TestUppercased</strong> мы уберем присваивание строки, т.е. под капотом</p><pre><code><span class="keyword">@Uppercased</span>(count: <span class="number">5</span>) <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span> 
</code></pre><p>вызывает <code></code><code>init(wrappedValue: String, count: Int)</code><code></code>, в качестве <strong>wrappedValue</strong> как раз передается значение которое мы присваиваем в value</p><p>Чтобы обойти это ограничение придется инициализацию проводить в конструкторе,</p><pre><code><span class="keyword">struct</span> TestUppercased2 {
    <span class="keyword">@Uppercased var</span> value: <span class="type">String</span>

    <span class="keyword">init</span>(count: <span class="type">Int</span>, example: <span class="type">String</span>) {
        _value = <span class="type">Uppercased</span>(wrappedValue: example, count: count)
    }
}

<span class="keyword">var</span> testAbs2 = <span class="type">TestUppercased2</span>(count: <span class="number">3</span>, example: <span class="string">"super puper"</span>)
<span class="call">print</span>(testAbs2.<span class="property">value</span>)
</code></pre><p>Если вы успели поработать со <strong>SwiftUI</strong> то думаю обратили внимание на переменные предваренные знаком доллара <strong>$value</strong>, их мы обычно передаем в дочернюю <strong>View</strong>, у которой переменная определена как <strong>@Binding</strong>. Proposal поясняет, для чего это нужно. Вспомним, что происходит если объявить переменную как <strong>PropertyWrapper</strong>, - снаружи типа невозможно будет получить к ней доступ</p><pre><code><span class="keyword">struct</span> TestSimplest {
    <span class="keyword">@Simplest var</span> value: <span class="type">String</span>

    <span class="comment">// будет развернуто в</span> 
    <span class="keyword">private var</span> _value: <span class="type">Simplest</span>
    <span class="keyword">var</span> value: <span class="type">String</span> { <span class="comment">/* доступ через _value.wrappedValue */</span> }
}
</code></pre><p>А что если мы хотим, чтобы пользователи структуры <strong>TestSimplest</strong> имели доступ к логике обертки ее свойства? Для этого надо в property wrapper определить свойство <strong>projectedValue</strong>.</p><pre><code><span class="keyword">@propertyWrapper
struct</span> VarWithMemory&lt;T&gt; {
    <span class="keyword">private var</span> _current: <span class="type">T</span>
    <span class="keyword">private (set) var</span> previousValues: [<span class="type">T</span>] = []

    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> {
        <span class="keyword">get</span> { _current }
        <span class="keyword">set</span> {
            previousValues.<span class="call">append</span>(_current)
            _current = newValue
        }
    }

    <span class="keyword">var</span> projectedValue: <span class="type">VarWithMemory</span>&lt;<span class="type">T</span>&gt; {
        <span class="keyword">get</span> { <span class="keyword">self</span> }
        <span class="keyword">set</span> { <span class="keyword">self</span> = newValue }
    }

    <span class="keyword">init</span>(wrappedValue: <span class="type">T</span>) {
        <span class="keyword">self</span>.<span class="property">_current</span> = wrappedValue
    }

    <span class="keyword">mutating func</span> clear() {
        previousValues.<span class="call">removeAll</span>()
    }

}

<span class="keyword">struct</span> TestVarWithMemory {
    <span class="keyword">@VarWithMemory var</span> value: <span class="type">String</span> = <span class="string">""</span>
}

<span class="keyword">var</span> test = <span class="type">TestVarWithMemory</span>(value: <span class="string">"initial"</span>)
<span class="call">print</span>(<span class="string">"1. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)
test.<span class="property">value</span> = <span class="string">"second"</span>
<span class="call">print</span>(<span class="string">"2. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)
test.<span class="property">value</span> = <span class="string">"third"</span>
<span class="call">print</span>(<span class="string">"3. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)

<span class="comment">// value: String, won't work
// print(test.value.previousValues)</span>

<span class="call">print</span>(<span class="string">"4. history:</span> \(test.$value.<span class="property">previousValues</span>)<span class="string">"</span>)
<span class="call">print</span>(<span class="string">"5. clear"</span>)
test.$value.<span class="call">clear</span>()
<span class="call">print</span>(<span class="string">"6. current value:</span> \(test.<span class="property">value</span>)<span class="string">"</span>)
<span class="call">print</span>(<span class="string">"7. history:</span> \(test.$value.<span class="property">previousValues</span>)<span class="string">"</span>)
</code></pre><p>Вывод в лог:</p><pre><code><span class="number">1</span>. <span class="property">current</span> value: initial
<span class="number">2</span>. <span class="property">current</span> value: second
<span class="number">3</span>. <span class="property">current</span> value: third
<span class="number">4</span>. <span class="property">history</span>: [<span class="string">"initial"</span>, <span class="string">"second"</span>]
<span class="number">5</span>. <span class="property">clear</span>
<span class="number">6</span>. <span class="property">current</span> value: third
<span class="number">7</span>. <span class="property">history</span>: []
</code></pre><p>Таким образом:</p><pre><code><span class="keyword">@VarWithMemory var</span> value: <span class="type">String</span> = <span class="string">""</span>
</code></pre><p>развернется во что то вроде</p><pre><code><span class="keyword">private var</span> _value: <span class="type">VarWithMemory</span>&lt;<span class="type">String</span>&gt; = <span class="type">VarWithMemory</span>(wrappedValue: <span class="string">""</span>)

<span class="keyword">public var</span> value: <span class="type">String</span> {
  <span class="keyword">get</span> { _value.<span class="property">wrappedValue</span> }
  <span class="keyword">set</span> { _value.<span class="property">wrappedValue</span> = newValue }
}

<span class="keyword">public var</span> $value: <span class="type">VarWithMemory</span>&lt;<span class="type">String</span>&gt; {
  <span class="keyword">get</span> { _value.<span class="property">projectedValue</span> }
  <span class="keyword">set</span> { _value.<span class="property">projectedValue</span> = newValue }
}
</code></pre><p>Важно отметит, что тип <strong>projectedValue</strong> может быть любой и не соответствовать типу в котором определена переменная. Это и позволило для <strong>@State</strong> при получении <strong>projectedValue</strong> через <strong>$</strong> - получать на выходе не <strong>State</strong>, а <strong>Binding</strong></p><p>Какие основные очевидные вариант применения можно придумать?</p><ul><li>когда работа со значением на самом деле проксируется и фактически переменная хранится в базе данных/<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#user-defaults">User Defaults</a></li><li>когда мы хотим как то преобразовать значение при присваивании, примером этого может быть приведенные выше <strong>Abs</strong>, <strong>Uppercased</strong>, ну или из proposal'а <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#clamping-a-value-within-bounds">Clamping</a> для обрезания значение по min/max границам</li><li>реализация <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#copy-on-write">Copy on Write</a></li></ul><p>ну и т.д.</p><p>Надо отметить, что есть определенные ограничения применения property wrapper'ов</p><ul><li>в протоколе нельзя указать, что это свойство должно быть обьявлено с таким то <strong>Property wrapper</strong>'ом</li><li>свойство с property wrapper'ом нельзя использовать в <strong>extension</strong> и <strong>enum</strong></li><li>свойство с property wrapper'ом нельзя переопределить в наследнике класса</li><li>свойство с property wrapper'ом не может быть <strong>lazy</strong>, <strong>@NSCopying</strong>, <strong>@NSManaged</strong>, <strong>weak</strong>, или <strong>unowned</strong>.</li><li>свойство с property wrapper'ом не может иметь кастомный <strong>get/set</strong></li><li>уровень доступа <strong>wrappedValue</strong>, и уровни доступа для всего нижеперечисленного (если присутствуют) должны быть идентичны уровню доступа типа в котором они определены: <strong>projectedValue</strong>, <strong>init(wrappedValue:)</strong>, <strong>init()</strong></li></ul><br/><p>Кстати, хотя обертки можно комбинировать, - есть один нюанс. Комбинирование происходит по принципу матрешки, и к примеру такой код:</p><pre><code><span class="keyword">struct</span> TestCombined {
    <span class="keyword">@VarWithMemory @Abs var</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">var</span> test = <span class="type">TestCombined</span>()
<span class="call">print</span>(test.<span class="property">value</span>)
test.<span class="property">value</span> = -<span class="number">1</span>
test.<span class="property">value</span> = -<span class="number">2</span>
test.<span class="property">value</span> = -<span class="number">3</span>
<span class="call">print</span>(test.<span class="property">value</span>)
<span class="call">print</span>(test.$value.<span class="property">previousValues</span>)
</code></pre><p>выдаст в лог</p><pre><code><span class="number">0
3</span>
[__lldb_expr_173.<span class="type">Abs</span>(_value: <span class="number">0</span>), __lldb_expr_173.<span class="type">Abs</span>(_value: <span class="number">1</span>), __lldb_expr_173.<span class="type">Abs</span>(_value: <span class="number">2</span>)]
</code></pre><p>а не ожидаемые</p><pre><code><span class="number">0
3</span>
[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]

</code></pre><p>На вход в <strong>VarWithMemory</strong> приходит переменна не типа <strong>Int</strong>, а типа <strong>Abs&lt;Int&gt;</strong> А если бы обертки были не <strong>Generic</strong>, а принимали к примеру только строки, то это даже бы не скомпилировалось. Красивого решения нет, можно к примеру делать специализированные версии оберток, чтобы один тип принимал в конструкторе второй, а внутри уже работать со внутренним типом второго.</p><h2>Подводя итоги.</h2><p>Какие достоинства у property wrapper'ов? Они позволяют спрятать кастомную логику за простым определением переменной добавив <strong>@&lt;Тип&gt;</strong></p><p>Какие минусы?</p><p>С точки зрения практического применения они исходят из их главного плюса, сложность обертки скрыта от глаз, даже сам факт, что ты работаешь с оберткой не очевиден, пока не посмотришь определение переменной. Поэтому я порекомендовал бы аккуратно использовать их в своем проекте.</p><p>Какие альтернативы?</p><ul><li>для создании логики типа <strong>Observer</strong> - использовать <strong>willSet/didSet</strong> у свойств</li><li>для добавления логики модификации/места хранения - использовать <strong>get/set</strong> у свойств</li></ul><br/><p><strong>Playground</strong> с исходниками из статьи доступен <a href="https://github.com/sparklone/property-wrappers-in-swift">здесь</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/make-auto-updated-swifui-views-preview-list</guid><title>Личная поваренная книга SwiftUI рецептов.</title><description>Создаем авто пополняемый список preview для SwiftUI Views</description><link>https://sparklone.github.io/articles/make-auto-updated-swifui-views-preview-list</link><pubDate>Wed, 22 Jul 2020 02:00:00 +0300</pubDate><content:encoded><![CDATA[<h1>Личная поваренная книга SwiftUI рецептов.</h1><p>Когда начинаешь разбираться в какой то обширной теме в программировании - количество скачанных проектов, созданных черновиков начинает превышать все мыслимые и немыслимые пределы. А потом всё перемешивается, теряется. Вроде помнил, что ты с этим работал, а где, когда? Я пробовал работать в Playground'ах, но они на мой взгляд не такие стабильные как обычный проект, отваливается подсветка, нет возможности нормально делать Debug. С недавних пор я завел единый проект для исследования SwiftUI, и все небольшие вещи закидываю туда. Это помогает держать все в одном месте, к тому же поиск внутри проекта намного удобней. Хоть SwiftUI и предоставляет Preview для быстрого просмотра View, даже позволяет их отлаживать, все же этого не всегда хватает. Хочется и на устройстве проверить. А если держать все эти View внутри одного проекта - надо при создании новой вьюхи проставлять ее как основную в SceneDelegate, что довольно быстро начинает утомлять. Как было бы круто, если бы мы могли видеть все наши тестовые View при запуске приложения и могли выбрать с чем работать. Фантастика скажете вы? Отнюдь )</p><p>Задачу думаю можно решить более чем одним путем. Навскидку - прикрутить Sourcery, но интересно было решить без вспомогательных инструментов.</p><p>Итак, что из себя представляет View и её Preview:</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello, World!"</span>)
    }
}

<span class="keyword">struct</span> ContentView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>Как мы видим предпросмотр для view обеспечивается структурой, которая имплементирует PreviewProvider, если кто не знал, можно даже внутри одного файла создавать сколь угодно структур/классов, которые будут имплементировать PreviewProvider и в зоне предпросмотра они отобразятся все. Может пригодиться, если хотим разбить наш ContentView_Previews на неколько с разными настройками (хотя можно это же сделать и внутри одной структуры имплементирующей PreviewProvider, но речь не об этом).</p><p>Что из себя представляет PreviewProvider - это протокол</p><pre><code><span class="comment">/// Produces view previews in Xcode.
///
/// Xcode statically discovers types that conform to `PreviewProvider` and
/// generates previews in the canvas for each provider it discovers.</span>
<span class="keyword">@available</span>(iOS <span class="number">13.0</span>, <span class="type">OSX</span> <span class="number">10.15</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">6.0</span>, *)
<span class="keyword">public protocol</span> PreviewProvider : <span class="type">_PreviewProvider</span> {

    <span class="comment">/// The type of the previews variable.</span>
    <span class="keyword">associatedtype</span> Previews : <span class="type">View</span>

    <span class="comment">/// Generates a collection of previews.
    ///
    /// Example:
    ///
    ///     struct MyPreviews : PreviewProvider {
    ///         static var previews: some View {
    ///             return Group {
    ///                 GreetingView("Hello"),
    ///                 GreetingView("Guten Tag"),
    ///
    ///                 ForEach(otherGreetings, id: \.self) {
    ///                     GreetingView($0)
    ///                 }
    ///             }
    ///             .previewDevice("iPhone X")
    ///         }
    ///     }</span>
    <span class="keyword">static var</span> previews: <span class="type">Self</span>.<span class="type">Previews</span> { <span class="keyword">get</span> }

    <span class="comment">/// Returns which platform to run the provider on.
    ///
    /// When `nil`, Xcode infers the platform based on the file the
    /// `PreviewProvider` is defined in. This should only be provided when the
    /// file is in targets that support multiple platforms.</span>
    <span class="keyword">static var</span> platform: <span class="type">PreviewPlatform</span>? { <span class="keyword">get</span> }
}
</code></pre><p>Главное, что можно извлечь из кода, это не простой протокол, а PAT: Protocol with Associated Type, что сразу усложняет дело. Я перепробовал много вариантов как обеспечить нужную функциональность с минимальными усилиями.</p><p>Начнем с того как вообще можно подобные вещи делать real time? В Objective-C мы могли делать все что угодно с помощью reflection - получать список всех кассов, исследовать их свойства. В swift это все дело сильно ограничили, и Mirror не даст нам всего необходимого. Поэтому пришлось смотреть в сторону objc_getClassList, это метод из Obj-C рантайма, который позволяет получить список всех классов. К сожалению такого нет для Swift структур, поэтому пришлось обходится тем, что дали.</p><p>Разберем решение по частям.</p><p>Не получится нормально работать с системным протоколом PreviewProvider из за того, что он PAT, поэтом создадим Erase версию этого протокола</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">protocol</span> PreviewHolder {
    <span class="keyword">static var</span> anyPreviews: <span class="type">AnyView</span> { <span class="keyword">get</span> }
    <span class="keyword">static var</span> name: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">static var</span> starred: <span class="type">Bool</span> { <span class="keyword">get</span> }
}

<span class="keyword">extension</span> <span class="type">PreviewHolder</span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> anyPreviews: <span class="type">AnyView</span> {
        <span class="type">AnyView</span>(previews)
    }

    <span class="keyword">static var</span> name: <span class="type">String</span> {
        <span class="type">String</span>(describing: <span class="keyword">self</span>).<span class="call">replacingOccurrences</span>(of: <span class="string">"_Previews"</span>, with: <span class="string">""</span>)
    }

    <span class="keyword">static var</span> starred: <span class="type">Bool</span> { <span class="keyword">false</span> }
}
</code></pre><p>1. Как видно я стер тип у previews, создав обертку anyPreviews, которая будет возвращать AnyView. Я не очень люблю такие штуки, потенциальная потеря производительности, но т.к. это не production код, то на это можно закрыть глаза.</p><p>2. name - свойство возвращающее имя нашей View, как оно будет отображатсья в списке, учитывая что все Preview имеют автоматом генерируемые имена <code></code><code>ViewName_Previews</code><code></code> - можно <code></code><code>_Previews</code><code></code> отрезать.</p><p>3. Я добавил свойство starred, т.к. число View будет все увеличиваться, и начиная работать с новым куском кода хочется увидеть его сверху в списке. Это можно сделать переопределив у превьюхи для новой View это свойство, возвращая true.</p><p>Сам список выглядит довольно просто.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> PreviewsList: <span class="type">View</span> {

    <span class="keyword">@State private var</span> starred: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>] = []

    <span class="keyword">@State private var</span> general: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>] = []

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Starred"</span>)) {
                    <span class="type">SubList</span>(elements: starred)
                }
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"General"</span>)) {
                    <span class="type">SubList</span>(elements: general)
                }
            }.<span class="call">navigationBarTitle</span>(<span class="string">"Catalog"</span>)
                .<span class="call">onAppear</span> {
                    <span class="keyword">let</span> sorted = <span class="type">PreviewUtils</span>.<span class="call">parse</span>().<span class="call">sorted</span>(by: { (lhs, rhs) -&gt; <span class="type">Bool</span> <span class="keyword">in</span>
                        lhs.<span class="property">name</span> &lt; rhs.<span class="property">name</span>
                    })
                    <span class="keyword">self</span>.<span class="property">starred</span> = sorted.<span class="call">filter</span> { $0.<span class="property">starred</span> }
                    <span class="keyword">self</span>.<span class="property">general</span> = sorted.<span class="call">filter</span> { !$0.<span class="property">starred</span> }
            }
        }
    }
}

<span class="keyword">private struct</span> SubList: <span class="type">View</span> {
    <span class="keyword">var</span> elements: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>]
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ForEach</span>(<span class="number">0</span>..&lt;elements.<span class="property">count</span>, id: \.<span class="keyword">self</span>) { id <span class="keyword">in
            return</span> <span class="type">NavigationLink</span>(destination: <span class="keyword">self</span>.<span class="property">elements</span>[id].anyPreviews) {
                <span class="type">Text</span>(<span class="keyword">self</span>.<span class="property">elements</span>[id].name)
            }
        }
    }
}

<span class="keyword">struct</span> PreviewsList_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">PreviewsList</span>()
    }
}
</code></pre><p>Все View сортируются по имени и разбивается на 2 списка, starred и обычные. Выглядеть все будет примерно так:</p><br/><img src="https://sparklone.github.io/blog/images/make-auto-updated-swifui-views-preview-list/list.png" width="300"/><p>Ну и в SceneDelegate просто меняем основную вьюху</p><pre><code><span class="keyword">let</span> contentView = <span class="type">PreviewsList</span>()
</code></pre><p>Остался последний момент, как же сделать так, чтобы наши Preview попали в этот список:</p><ul><li>поменять struct на class</li><li>добавить поддержку PreviewHolder</li></ul><br/><p>т.е. вместо</p><pre><code><span class="keyword">struct</span> ContentView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>станет</p><pre><code><span class="keyword">class</span> ContentView_Previews: <span class="type">PreviewProvider</span>, <span class="type">PreviewHolder</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>Опционально можно переопределять name и starred.</p><p>Это решение написано за пару часов, чтобы по быстрому испытать идею. При желании его можно наворотить по полной, проставляя теги, дату создания для Preview, показывать список не основным, а в в Debug окне, что позволит использовать даже на боевом проекте (не забываем отключать в Release сборке). В общем все зависит от вашей фантазии )</p><p>Скачать проект с базовой реализацией можно здесь: <a href="https://github.com/sparklone/swiftui-views-preview-list" target="_blank">Github</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/debug-swiftui-views</guid><title>Отладка SwiftUI views</title><description>Как отслеживать создание и отрисовку SwiftUI views</description><link>https://sparklone.github.io/articles/debug-swiftui-views</link><pubDate>Sat, 11 Jul 2020 19:58:00 +0300</pubDate><content:encoded><![CDATA[<h1>Отладка SwiftUI views</h1><p>SwiftUI прикладывает массу усилий, чтобы UI не лагал при перерисовке. Если мы хотим лучше понимать как работает фреймворк под капотом - стоит копнуть чуть глубже.</p><p>По сути нас интересуют два события - когда View пересоздается, и когда запрашивается на самом деле body для перерисовки.</p><p>Это побудило меня создать обертку позволяющую отслеживать эти события</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">public struct</span> DebugView&lt;MainView: <span class="type">View</span>&gt;: <span class="type">View</span> {
    <span class="keyword">private let</span> view: <span class="type">MainView</span>
    <span class="keyword">private let</span> logType: <span class="type">LogType</span>

    <span class="keyword">private enum</span> LogType {
        <span class="keyword">case</span> onlyDescription(<span class="type">String</span>)
        <span class="keyword">case</span> descriptionAndDumpView(<span class="type">String</span>)
        <span class="keyword">case</span> dumpView
    }

    <span class="keyword">private var</span> about: <span class="type">String</span> {
        <span class="keyword">switch</span> logType {
            <span class="keyword">case let</span> .<span class="call">onlyDescription</span>(description):
                <span class="keyword">return</span> <span class="string">"</span>\(description)<span class="string">"</span>
            <span class="keyword">case let</span> .<span class="call">descriptionAndDumpView</span>(description):
                <span class="keyword">return</span> <span class="string">"</span>\(description)<span class="string">:</span> \(view)<span class="string">"</span>
            <span class="keyword">case</span> .<span class="dotAccess">dumpView</span>:
                <span class="keyword">return</span> <span class="string">"</span>\(view)<span class="string">"</span>
            }
        }

    <span class="keyword">public init</span>(view: <span class="type">MainView</span>, description: <span class="type">String</span>?, dumpView: <span class="type">Bool</span> = <span class="keyword">true</span>) {
        <span class="keyword">self</span>.<span class="property">view</span> = view
        <span class="keyword">if let</span> description = description {
            <span class="keyword">if</span> dumpView {
                logType = .<span class="call">descriptionAndDumpView</span>(description)
            } <span class="keyword">else</span> {
                logType = .<span class="call">onlyDescription</span>(description)
            }
        } <span class="keyword">else</span> {
            logType = .<span class="dotAccess">dumpView</span>
        }
        <span class="call">print</span>(<span class="string">"init:</span> \(about)<span class="string">"</span>)
    }

    <span class="keyword">public var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="call">print</span>(<span class="string">"body:</span> \(about)<span class="string">"</span>)
        <span class="keyword">return</span> view
    }
}

<span class="keyword">extension</span> <span class="type">View</span> {
    <span class="keyword">public func</span> debug() -&gt; <span class="type">DebugView</span>&lt;<span class="type">Self</span>&gt; {
        <span class="keyword">return</span> <span class="type">DebugView</span>(view: <span class="keyword">self</span>, description: <span class="keyword">nil</span>)
    }

    <span class="keyword">public func</span> debug(<span class="keyword">_</span> description: <span class="type">String</span>, dumpView: <span class="type">Bool</span> = <span class="keyword">false</span>) -&gt; <span class="type">DebugView</span>&lt;<span class="type">Self</span>&gt; {
        <span class="keyword">return</span> <span class="type">DebugView</span>(
            view: <span class="keyword">self</span>,
            description: description,
            dumpView: dumpView
        )
    }
}
</code></pre><p>Вот ее <a href="https://gist.github.com/sparklone/6f64156ed6de87c1020198d93f4c45a3">Gist</a></p><p>По большому счету, это View - прокси. Давайте попробуем поработать с этим. Создадим playground в котором мы посмотрим работу с SwiftUI views в динамике</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">private struct</span> MyListView: <span class="type">View</span> {
    <span class="keyword">@State var</span> numberOfViews: <span class="type">Int</span> = <span class="number">1</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(spacing: <span class="number">30</span>) {
            <span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
                <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>).<span class="call">debug</span>(<span class="string">"Text:</span> \(id)<span class="string">"</span>)
            }
            <span class="type">HStack</span> {
                <span class="type">Text</span>(<span class="string">"</span>\(numberOfViews)<span class="string">"</span>)
                <span class="type">Button</span>(<span class="string">"numberOfViews"</span>) {
                    <span class="keyword">self</span>.<span class="property">numberOfViews</span> += <span class="number">1</span>
                }
            }
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">MyListView</span>().<span class="call">debug</span>(<span class="string">"MyListView"</span>))
</code></pre><p>При старте в логах мы увидим</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">Text</span>: <span class="number">0</span>
body: <span class="type">Text</span>: <span class="number">0</span>

</code></pre><p>Выглядит разумно, при старте приложения система сначала создает MyListView, берет у нее body, видит что нужен один Text, создает его и затем уже у него просит body.</p><p>Нажимаем один раз на кнопку numberOfViews В логах добавится следующее:</p><pre><code>init: <span class="type">Text</span>: <span class="number">0</span>
init: <span class="type">Text</span>: <span class="number">1</span>
body: <span class="type">Text</span>: <span class="number">1</span>
</code></pre><p>А вот это уже интересно, мы видим, что пересоздания MyListView не происходит, что выглядит логично, а вот Text создается 2 раза (view стало 2 после увеличения счетчика), но body запросился только у нового элемента на экране.</p><p>Если еще раз нажать на кнопку numberOfViews увидим уже ожидаемое</p><pre><code>init: <span class="type">Text</span>: <span class="number">0</span>
init: <span class="type">Text</span>: <span class="number">1</span>
init: <span class="type">Text</span>: <span class="number">2</span>
body: <span class="type">Text</span>: <span class="number">2</span>
</code></pre><p>Т.е. body будет вызываться только для новых элементов.</p><p>Попробуем понять как и почему так работает система.</p><p>Создадим свою View - MyTextView и сделаем так, чтобы при каждом создании - генерировался уникальный контент</p><pre><code><span class="keyword">private struct</span> MyText: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(<span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>))<span class="string">"</span>)
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">MyText</span>().<span class="call">debug</span>(<span class="string">"MyText:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>На старте видим в логах</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">MyText</span>: <span class="number">0</span>
body: <span class="type">MyText</span>: <span class="number">0</span>

</code></pre><p>После нажатия на кнопку numberOfViews</p><pre><code>init: <span class="type">MyText</span>: <span class="number">0</span>
init: <span class="type">MyText</span>: <span class="number">1</span>
body: <span class="type">MyText</span>: <span class="number">1</span>
</code></pre><p>При этом, мы ожидаем, что на экране для ранее показанного элемента изменится число (random же как никак), но по факту число не меняется. Т.е. система создает MyText, но по всей видимости отбрасывает не перерисовывая. Почему? Потому что система считает, что все MyText - одинаковы, т.к. эта структура не реализует Equatable.</p><p>Проверим нашу догадку</p><pre><code><span class="keyword">private struct</span> MyTextEquatable: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>() {
        id = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>)
    }
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">MyTextEquatable</span>().<span class="call">debug</span>(<span class="string">"MyTextEquatable:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>Первый запуск</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
</code></pre><p>Нажимаем на кнопку</p><pre><code>init: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
init: <span class="type">MyTextEquatable</span>: <span class="number">1</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">1</span>
</code></pre><p>Заработало, это видно не только из логов, но и в preivew, после каждого нажатия кнопки - все числа меняются. Теперь кажется все встает на свои места, при каждом обновлении View система создает его детей (именно поэтому инициализаторы для View должны быть максимально легковесными, никакой "тяжелой" логики в конструктор помещать не стоит), сравнивает по протоколу Equatable - изменилось ли внутреннее состояние, если нет - система считает что перерисовка не нужна, т.к. View не обновилось.</p><p>Проверим, создадим следующее</p><pre><code><span class="keyword">private struct</span> StupidView: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">StupidView</span>, rhs: <span class="type">StupidView</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">StupidView</span>().<span class="call">debug</span>(<span class="string">"StupidView:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>При старте</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">StupidView</span>: <span class="number">0</span>
body: <span class="type">StupidView</span>: <span class="number">0</span>
</code></pre><p>После нажатия</p><pre><code>init: <span class="type">StupidView</span>: <span class="number">0</span>
init: <span class="type">StupidView</span>: <span class="number">1</span>
body: <span class="type">StupidView</span>: <span class="number">1</span>
</code></pre><p>Что за черт, мы же возвращаем false всегда при сравнении! Чтобы поотлаживать SwiftUI view надо будет создать полноценный проект и создать там новый файл с содержимым</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">private struct</span> MyListView: <span class="type">View</span> {
    <span class="keyword">@State var</span> numberOfViews: <span class="type">Int</span> = <span class="number">1</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(spacing: <span class="number">30</span>) {
            <span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
                <span class="type">StupidView</span>(id: id).<span class="call">debug</span>(<span class="string">"StupidView:</span> \(id)<span class="string">"</span>)
            }
            <span class="type">HStack</span> {
                <span class="type">Text</span>(<span class="string">"</span>\(numberOfViews)<span class="string">"</span>)
                <span class="type">Button</span>(<span class="string">"numberOfViews"</span>) {
                    <span class="keyword">self</span>.<span class="property">numberOfViews</span> += <span class="number">1</span>
                }
            }
        }
    }
}

<span class="keyword">private struct</span> StupidView: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">StupidView</span>, rhs: <span class="type">StupidView</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}

<span class="keyword">struct</span> EquatableSwiftUIStupid_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">MyListView</span>()
    }
}
</code></pre><p>Если в preview вызывать контекстное меню у кнопки play - появится возможность сделать Debug preview.</p><br/><img src="https://sparklone.github.io/blog/images/debug-swiftui-views/debug-preview.png" width="300"/><br/><br/><br/><p>Что мы наблюдаем при отладке? Точки останова срабатывают внутри var body, но не срабатывают внутри static func == Почему то система не вызывает наш метод для сравнения. Очень уж умный SwiftUI. В итоге я нашел как это обойти - использовать вместо Int класс обертку Holder. Видимо в этом случае SwiftUI решает все же положиться на предоставленную реализацию, т.к. у нас уже не простой value type.</p><p>Проверим</p><pre><code><span class="keyword">private class</span> Holder {
    <span class="keyword">var</span> id: <span class="type">Int</span>

    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }
}

<span class="keyword">private struct</span> StupidViewWithHolder: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> holder: <span class="type">Holder</span>
    <span class="keyword">init</span>(holder: <span class="type">Holder</span>) {
        <span class="keyword">self</span>.<span class="property">holder</span> = holder
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(holder.<span class="property">id</span>)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}

</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">StupidViewWithHolder</span>(holder: <span class="type">Holder</span>(id: id))
                    .<span class="call">debug</span>(<span class="string">"StupidViewWithHolder:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>При старте</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>

</code></pre><p>после нажатия</p><pre><code>init: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
init: <span class="type">StupidViewWithHolder</span>: <span class="number">1</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">1</span>
</code></pre><p>Наконец то мы добились реальной перерисовки элементов!</p><p>Стоит понимать, что не стоит на это закладываться при разработке, т.к. это внутреннее поведение SwiftUI, которое может измениться в любой момент. Но знания могут помочь понять что может вообще пойти не так и не тратить кучу времени на отладку реально сложных View. Теперь мы знаем очередной подводный камень SwiftUI, к тому же новый инструмент по дебагу View доказал свою состоятельность. Надеюсь было полезно )</p><p>Скачать Playground со всеми примерами из статьи можно здесь: <a href="https://github.com/sparklone/debug-swiftui-views">Playground</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/create-blog-using-swift-and-publish-and-deploy-to-github-pages</guid><title>Создаем блог на Swift с помощью Publish с размещением на GitHub Pages</title><description>Создаем блог на Swift с помощью Publish на GitHub Pages</description><link>https://sparklone.github.io/articles/create-blog-using-swift-and-publish-and-deploy-to-github-pages</link><pubDate>Fri, 10 Jul 2020 19:23:00 +0300</pubDate><content:encoded><![CDATA[<h1>Создаем блог на Swift с помощью Publish с размещением на GitHub Pages</h1><p>У меня уже есть блог, он на WordPress и я устал от всей этой свистопляски с обновлением версии, плагинов, возможности взлома и прочего. Это буквально убивает желание продолжать его развивать. Моя цель - делиться с миром своими мыслями и находками, но при этом иметь полный контроль над своим сайтом. С недавних пор Github Pages предоставила возможность хранить простенькие сайты у них. Никаких баз данных и PHP, статический сайт, как в старые добрые. Для блога - идеально. А т.к. процесс деплоя будет проходить через GitHub - будет прозрачная история всех изменений, и полный контроль над тем, что реально находится на сайте, трояны и прочая нечисть не пройдут.</p><p>Но они предлагают использовать Jekyll, статический генератор сайтов написанный на Ruby. Все же хочется отачивать мастерство в том языке, который ты используешь ежедневно, поэтому в качестве альтернативы я взял свежий статический генератор написанный на Swift от John Sundell.</p><p>Нам предстоит сделать 3 вещи:</p><ol><li><a href="#create-blog">создать блог на GitРub Pages</a></li><li><a href="#publish">разобраться с тем как работать с Publish</a></li><li><a href="#deploy">залить свой новый блог на GitРub Pages</a> <br/><br/> Итак, перейдем к пункту 1</li></ol><h2><a name="create-blog"></a> 1. Создадим блог на Github Pages.</h2><p>Официальная инструкция доступен по адресу <a href="https://pages.github.com">https://pages.github.com</a></p><p>Основное условие - login блога должен совпадать с вашим логином на GitHub. В моем случае это sparklone</p><ul><li>логинимся в GitHub</li><li>идем по адресу <a href="https://github.com/new">https://github.com/new</a></li><li>в качестве имени репозитория вводите <em>login</em>.github.io, в моем случае было sparklone.github.io</li><li>убеждаемся, что он будет Public</li><li>жмем Create Repository</li><li>все, наш блог уже доступен по адресу https://<em>login</em>.github.io</li></ul><br/><p>Но пока на сайте нет ни одного файл Можно переходить ко второму пункту</p><h2><a name="publish"></a> 2. Разберёмся с тем как работать с Publish</h2><p>Еще раз <a href="https://github.com/JohnSundell/Publish">Publish</a> - это статический генератор сайтов написанный на Swift, что позволяет выстраивать любую логику при генерации сайта, теги, карта сайта, rss, специфическая перелинковка. Все на что нам хватит фантазии. Одна из моих идей на будущее - попробовать писать статьи на двух языках, и чтобы настроенный шаблон умел это понимать и вставлять переключатель в статью к примеру. Не знаю дойдут ли когда нибудь до этого руки, но как идея - интересно.</p><p>Я предпочел установить напрямую через git, создал папку ~/Developer/tools и там выполнил</p><pre><code>git clone https://github.<span class="property">com</span>/<span class="type">JohnSundell</span>/<span class="type">Publish</span>.<span class="property">git</span>
cd <span class="type">Publish</span>
make
</code></pre><p>далее я создал папку где я планирую хранить свой сайт (точнее исходники его генератора), в моем случае это ~/Developer/my/blog</p><p>и внутри этой папки запускаем команду</p><pre><code>publish new
</code></pre><p>Это создаст новый сайт, список опций для команды можно узнать просто запустив в консоли publish</p><p><em>publish run</em> скомпилирует все исходники и запустит веб сервер на питоне (если прервать посредством Ctrl+C - веб сервер не умрет, и придется в процессах ковыряться чтобы убить Python)</p><p>Первая сборка занимает какое то время (подливаются нужные репозитории, компилируется все), при последующих запусках <em>publish run</em> - все происходит намного быстрее.</p><p>Открываем в браузере http://localhost:8000 и видим что получился за сайт</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/blog-initial.png" width="600"/><p>Не густо, но мы еще ничего собственно и не сделали, чтобы ожидать чего то большего.</p><p>Настройку стилей и прочие моменты я оставлю на потом. На сегодня вижу перед собой следующие задачи</p><ol><li>сделать изначальную настройку генератора для нашего сайта</li><li>поменять пути по которым будут лежать записи и настроить меню</li><li>добавить подсветку для исходных файлов и создание своей темы <br/><br/></li></ol><h3>1. Изначальная настройка генератора для нашего сайта</h3><br/><p>Посмотрим что нам сгенерировал Publish. Внутри папки будет файл Package.swift, его открываем XCode'ом (можно в консоли набрать open Package.swift), и это запускает процесс подтягивания всех нужных библиотек. На скрине видно что должно получится в итоге.</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/publish-initial-screen.png" width="600"/><p>Тестовая запись лежит в Content/posts/first-post.md Проверим, что мы можем что то изменить и это отразится на сайте Подправим текст в first-post.md (можно поменять дату, теги, описания, и сам контент)</p><p>В Xcode выбираем Mac в качества таргета для которого надо запускать и делаем Run проекту.</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/blog-how-to-run.png" width="600"/><p>После этого рефрешим веб страницу <a href="http://localhost:8000">http://localhost:8000</a></p><h4>2. Меняем пути по которым будут лежать записи и настраиваем меню</h4><p>Почему это важно сделать сразу? Если вы решите поменять пути после того как уже зальете часть постов - входящие ссылки на эти страницы станут невалидными, а т.к. это не свой сервер/VPS - будет довольно проблематично сделать редирект со старых ссылок на новые пути. Не невозможно (вот к примеру плагин для <a href="https://github.com/jekyll/jekyll-redirect-from">Jekyll</a>), но зачем создавать себе головную боль в будущем если можно ее избежать.</p><p>По умолчанию все записи лежать в папке posts. Учитывая что в дальнейшем хочется бить на категории, а posts - общее название, - лучше переименовать папку в articles. Так же не помешает добавить страницу about</p><p>Но наш генератор пока ничего не знает про это.</p><p>В main.swift поменяем на</p><pre><code><span class="keyword">struct</span> Blog: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> articles
        <span class="keyword">case</span> about
    }
}
</code></pre><p>Добавим файл <em>about.md</em> в папку <em>Content</em> и заполним немного информации о себе</p><p>К слову эту статью я пишу в XCode, редактируя md файл, и периодически запуская проект, чтобы посмотреть в браузере как это смотрится.</p><p>Я долго колебался заморачиваться ли с датой у файлов *.md, ну т.е. называть не my-article.md, а к примеру 2020-07-10-my-article.md. И все же решил отказаться от этой идеи. Т.к. в самих md файлах есть метаданные (поле date), это при желании позволит в будущем добавлять дату автоматически. И не придется следить за корректностью даты в имени файла, к тому же это убережет от расхождений, если в имени файла одна дата, а в метаданных внутри - другая. Недостатком такого решения я вижу то, что гипотетически могут в будущем быть коллизии в именах md файлов, но все таки это маловероятно, к тому же мы об этом узнаем при создании поста, а не сохранении.</p><h4>3. Добавляем подсветку для исходных файлов</h4><p>Автором генератора Publish так же была написана библиотека <a href="https://github.com/JohnSundell/Splash">Splash</a> позволяющая делать подсветку исходных кодов. Подключается она как package в Swift Package Manager</p><p>Открываем файл Package.swift и добавляем поддержку, по сути нужно добавить 2 строки Вот что получилось у меня</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    name: <span class="string">"Blog"</span>,
    products: [
        .<span class="call">executable</span>(
            name: <span class="string">"Blog"</span>,
            targets: [<span class="string">"Blog"</span>]
        )
    ],
    dependencies: [
        .<span class="call">package</span>(name: <span class="string">"Publish"</span>, url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.6.0"</span>),
        .<span class="call">package</span>(name: <span class="string">"SplashPublishPlugin"</span>, url: <span class="string">"https://github.com/johnsundell/splashpublishplugin"</span>, from: <span class="string">"0.1.0"</span>)
    ],
    targets: [
        .<span class="call">target</span>(
            name: <span class="string">"Blog"</span>,
            dependencies: [
                <span class="string">"Publish"</span>,
                <span class="string">"SplashPublishPlugin"</span>
            ]
        )
    ]
)
</code></pre><p>А чтобы подсветка начала применяться при генерации нужно подклбючить плагин в main.swift</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>я поменял на</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">foundation</span>,
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><p>Не забываем добавить в <em>main.swift</em> импорт плагина <code></code><code>import SplashPublishPlugin</code><code></code></p><p>Если сгенерировать сайт сейчас мы увидим, что блоки с кодом будут выделяться, но не подсвечиваться, это связано с тем, что нужно добавить <a href="https://github.com/JohnSundell/Splash/blob/master/Examples/sundellsColors.css">CSS</a>, будем использовать тот, который по умолчанию используется автором плагина.</p><p>Но вот проблема - куда добавлять этот CSS? Если покопаться в исходниках, то станет видно, что все это решается на уровне темы. Тема у нас стандартная <em>foundation</em>, и она лежит в самом пакете <em>Publish</em> по пути <a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/Theme%2BFoundation.swift">Sources/Publish/API/Theme+Foundation.swift</a></p><p>Внутри своего проекта (Blog) в папке где лежит <em>main.swift</em> я создал подобный файл <em>Theme+Blog.swift</em> Так же внутри папки Resources я создал папку Blog и поместил туда файл styles.css Внутрь файла я поместил содержимое CSS от темы <a href="https://github.com/JohnSundell/Publish/blob/master/Resources/FoundationTheme/styles.css">Foundation</a> ну и CSS от <a href="https://github.com/JohnSundell/Splash/blob/master/Examples/sundellsColors.css">Splash</a> Да, лучше было бы разделить, а может вообще темы вынести в отдельный package, но не будем усложнять раньше времени.</p><p>Итого у меня в файле темы пришлось поменять на следующее</p><pre><code><span class="keyword">import</span> Plot
<span class="keyword">import</span> Publish

<span class="keyword">public extension</span> <span class="type">Theme</span> {
    <span class="keyword">static var</span> blog: <span class="type">Self</span> {
        <span class="type">Theme</span>(
            htmlFactory: <span class="type">BlogHTMLFactory</span>(),
            resourcePaths: [<span class="string">"resources/blog/styles.css"</span>]
        )
    }
}
</code></pre><p>Если бы мы добавили еще один css, нам потребовалось бы не только добавит его в resourcePaths, но так же добавлять в каждый head страниц, чего мне делать совершенно не хотелось в данный момент</p><pre><code>.<span class="call">head</span>(for: item, on: context.<span class="property">site</span>, stylesheetPaths: [<span class="string">"/styles.css"</span>, <span class="string">"/splash.css"</span>]),
</code></pre><p>Итого сейчас у меня в проекте файловая структура выглядит как то так:</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/final-structure.png" width="400"/><h2><a name="deploy"></a> 3. Зальём свой новый блог на GitРub Pages</h2><p>Итак, воспользуемся встроенным инструментом Publish для заливки нашего блога. В <em>main.swift</em> добавим</p><pre><code>.<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"login/login.github.io"</span>, useSSH: <span class="keyword">false</span>))
</code></pre><p>итого у меня получилось</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">blog</span>,
    deployedUsing: .<span class="call">gitHub</span>(<span class="string">"sparklone/sparklone.github.io"</span>, useSSH: <span class="keyword">false</span>),
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><p>Проверяем в последний раз, что все работает. Последний штрих - мне кажется, что нет смысла хранить в git нашего репозитория с темплейтами как строить сайт содержимое папки Output, для этого у нас будет отдельный репозиторий как раз таки <em>login.github.io</em> Если вы согласны - исключим эту папку из .gitignore, добавив туда строку <em>/Output</em> в конце Если все ок выполняем в консоли (из папки где мы выполняли publish new)</p><pre><code>git add .
git commit -m <span class="string">"post title or some description"</span>
git push origin
publish deploy
</code></pre><p>В течении минуты GitHub Pages подхватит ваши изменения и все появится онлайн.</p><br/><p>Поздравляю! )</p>]]></content:encoded></item></channel></rss>