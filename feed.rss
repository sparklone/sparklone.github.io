<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Каморка сурового программиста, дубль 2</title><description>Блог о технологиях, преимущественно о Swift и обо всём, что связано с Apple</description><link>https://sparklone.github.io</link><language>ru</language><lastBuildDate>Wed, 22 Jul 2020 01:55:17 +0300</lastBuildDate><pubDate>Wed, 22 Jul 2020 01:55:17 +0300</pubDate><ttl>250</ttl><atom:link href="https://sparklone.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://sparklone.github.io/articles/make-auto-updated-swifui-views-preview-list</guid><title>Личная поваренная книга SwiftUI рецептов</title><description>Создаем авто пополняемый список preview для SwiftUI Views</description><link>https://sparklone.github.io/articles/make-auto-updated-swifui-views-preview-list</link><pubDate>Wed, 22 Jul 2020 02:00:00 +0300</pubDate><content:encoded><![CDATA[<h1>Личная поваренная книга SwiftUI рецептов</h1><p>Когда начинаешь разбираться в какой то обширной теме в программировании - количество скачанных проектов, созданных черновиков начинает превышать все мыслимые и немыслимые пределы. А потом всё перемешивается, теряется. Вроде помнил, что ты с этим работал, а где, когда? Я пробовал работать в Playground'ах, но они на мой взгляд не такие стабильные как обычный проект, отваливается подсветка, нет возможности нормально делать Debug. С недавних пор я завел единый проект для исследования SwiftUI, и все небольшие вещи закидываю туда. Это помогает держать все в одном месте, к тому же поиск внутри проекта намного удобней. Хоть SwiftUI и предоставляет Preview для быстрого просмотра View, даже позволяет их отлаживать, все же этого не всегда хватает. Хочется и на устройстве проверить. А если держать все эти View внутри одного проекта - надо при создании новой вьюхи проставлять ее как основную в SceneDelegate, что довольно быстро начинает утомлять. Как было бы круто, если бы мы могли видеть все наши тестовые View при запуске приложения и могли выбрать с чем работать. Фантастика скажете вы? Отнюдь )</p><p>Задачу думаю можно решить более чем одним путем. Навскидку - прикрутить Sourcery, но интересно было решить без вспомогательных инструментов.</p><p>Итак, что из себя представляет View и её Preview:</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello, World!"</span>)
    }
}

<span class="keyword">struct</span> ContentView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>Как мы видим предпросмотр для view обеспечивается структурой, которая имплементирует PreviewProvider, если кто не знал, можно даже внутри одного файла создавать сколь угодно структур/классов, которые будут имплементировать PreviewProvider и в зоне предпросмотра они отобразятся все. Может пригодиться, если хотим разбить наш ContentView_Previews на неколько с разными настройками (хотя можно это же сделать и внутри одной структуры имплементирующей PreviewProvider, но речь не об этом).</p><p>Что из себя представляет PreviewProvider - это протокол</p><pre><code><span class="comment">/// Produces view previews in Xcode.
///
/// Xcode statically discovers types that conform to `PreviewProvider` and
/// generates previews in the canvas for each provider it discovers.</span>
<span class="keyword">@available</span>(iOS <span class="number">13.0</span>, <span class="type">OSX</span> <span class="number">10.15</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">6.0</span>, *)
<span class="keyword">public protocol</span> PreviewProvider : <span class="type">_PreviewProvider</span> {

    <span class="comment">/// The type of the previews variable.</span>
    <span class="keyword">associatedtype</span> Previews : <span class="type">View</span>

    <span class="comment">/// Generates a collection of previews.
    ///
    /// Example:
    ///
    ///     struct MyPreviews : PreviewProvider {
    ///         static var previews: some View {
    ///             return Group {
    ///                 GreetingView("Hello"),
    ///                 GreetingView("Guten Tag"),
    ///
    ///                 ForEach(otherGreetings, id: \.self) {
    ///                     GreetingView($0)
    ///                 }
    ///             }
    ///             .previewDevice("iPhone X")
    ///         }
    ///     }</span>
    <span class="keyword">static var</span> previews: <span class="type">Self</span>.<span class="type">Previews</span> { <span class="keyword">get</span> }

    <span class="comment">/// Returns which platform to run the provider on.
    ///
    /// When `nil`, Xcode infers the platform based on the file the
    /// `PreviewProvider` is defined in. This should only be provided when the
    /// file is in targets that support multiple platforms.</span>
    <span class="keyword">static var</span> platform: <span class="type">PreviewPlatform</span>? { <span class="keyword">get</span> }
}
</code></pre><p>Главное, что можно извлечь из кода, это не простой протокол, а PAT: Protocol with Associated Type, что сразу усложняет дело. Я перепробовал много вариантов как обеспечить нужную функциональность с минимальными усилиями.</p><p>Начнем с того как вообще можно подобные вещи делать real time? В Objective-C мы могли делать все что угодно с помощью reflection - получать список всех кассов, исследовать их свойства. В swift это все дело сильно ограничили, и Mirror не даст нам всего необходимого. Поэтому пришлось смотреть в сторону objc_getClassList, это метод из Obj-C рантайма, который позволяет получить список всех классов. К сожалению такого нет для Swift структур, поэтому пришлось обходится тем, что дали.</p><p>Разберем решение по частям.</p><p>Не получится нормально работать с системным протоколом PreviewProvider из за того, что он PAT, поэтом создадим Erase версию этого протокола</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">protocol</span> PreviewHolder {
    <span class="keyword">static var</span> anyPreviews: <span class="type">AnyView</span> { <span class="keyword">get</span> }
    <span class="keyword">static var</span> name: <span class="type">String</span> { <span class="keyword">get</span> }
    <span class="keyword">static var</span> starred: <span class="type">Bool</span> { <span class="keyword">get</span> }
}

<span class="keyword">extension</span> <span class="type">PreviewHolder</span> <span class="keyword">where</span> <span class="type">Self</span>: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> anyPreviews: <span class="type">AnyView</span> {
        <span class="type">AnyView</span>(previews)
    }

    <span class="keyword">static var</span> name: <span class="type">String</span> {
        <span class="type">String</span>(describing: <span class="keyword">self</span>).<span class="call">replacingOccurrences</span>(of: <span class="string">"_Previews"</span>, with: <span class="string">""</span>)
    }

    <span class="keyword">static var</span> starred: <span class="type">Bool</span> { <span class="keyword">false</span> }
}
</code></pre><p>1. Как видно я стер тип у previews, создав обертку anyPreviews, которая будет возвращать AnyView. Я не очень люблю такие штуки, потенциальная потеря производительности, но т.к. это не production код, то на это можно закрыть глаза.</p><p>2. name - свойство возвращающее имя нашей View, как оно будет отображатсья в списке, учитывая что все Preview имеют автоматом генерируемые имена <code></code><code>ViewName_Previews</code><code></code> - можно <code></code><code>_Previews</code><code></code> отрезать.</p><p>3. Я добавил свойство starred, т.к. число View будет все увеличиваться, и начиная работать с новым куском кода хочется увидеть его сверху в списке. Это можно сделать переопределив у превьюхи для новой View это свойство, возвращая true.</p><p>Сам список выглядит довольно просто.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> PreviewsList: <span class="type">View</span> {

    <span class="keyword">@State private var</span> starred: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>] = []

    <span class="keyword">@State private var</span> general: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>] = []

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">List</span> {
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"Starred"</span>)) {
                    <span class="type">SubList</span>(elements: starred)
                }
                <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"General"</span>)) {
                    <span class="type">SubList</span>(elements: general)
                }
            }.<span class="call">navigationBarTitle</span>(<span class="string">"Catalog"</span>)
                .<span class="call">onAppear</span> {
                    <span class="keyword">let</span> sorted = <span class="type">PreviewUtils</span>.<span class="call">parse</span>().<span class="call">sorted</span>(by: { (lhs, rhs) -&gt; <span class="type">Bool</span> <span class="keyword">in</span>
                        lhs.<span class="property">name</span> &lt; rhs.<span class="property">name</span>
                    })
                    <span class="keyword">self</span>.<span class="property">starred</span> = sorted.<span class="call">filter</span> { $0.<span class="property">starred</span> }
                    <span class="keyword">self</span>.<span class="property">general</span> = sorted.<span class="call">filter</span> { !$0.<span class="property">starred</span> }
            }
        }
    }
}

<span class="keyword">private struct</span> SubList: <span class="type">View</span> {
    <span class="keyword">var</span> elements: [<span class="type">PreviewHolder</span>.<span class="type">Type</span>]
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ForEach</span>(<span class="number">0</span>..&lt;elements.<span class="property">count</span>, id: \.<span class="keyword">self</span>) { id <span class="keyword">in
            return</span> <span class="type">NavigationLink</span>(destination: <span class="keyword">self</span>.<span class="property">elements</span>[id].anyPreviews) {
                <span class="type">Text</span>(<span class="keyword">self</span>.<span class="property">elements</span>[id].name)
            }
        }
    }
}

<span class="keyword">struct</span> PreviewsList_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">PreviewsList</span>()
    }
}
</code></pre><p>Все View сортируются по имени и разбивается на 2 списка, starred и обычные. Выглядеть все будет примерно так:</p><br/><img src="https://sparklone.github.io/blog/images/make-auto-updated-swifui-views-preview-list/list.png" width="300"/><p>Ну и в SceneDelegate просто меняем основную вьюху</p><pre><code><span class="keyword">let</span> contentView = <span class="type">PreviewsList</span>()
</code></pre><p>Остался последний момент, как же сделать так, чтобы наши Preview попали в этот список:</p><ul><li>поменять struct на class</li><li>добавить поддержку PreviewHolder</li></ul><br/><p>т.е. вместо</p><pre><code><span class="keyword">struct</span> ContentView_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>станет</p><pre><code><span class="keyword">class</span> ContentView_Previews: <span class="type">PreviewProvider</span>, <span class="type">PreviewHolder</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">ContentView</span>()
    }
}
</code></pre><p>Опционально можно переопределять name и starred.</p><p>Это решение написано за пару часов, чтобы по быстрому испытать идею. При желании его можно наворотить по полной, проставляя теги, дату создания для Preview, показывать список не основным, а в в Debug окне, что позволит использовать даже на боевом проекте (не забываем отключать в Release сборке). В общем все зависит от вашей фантазии )</p><p>Скачать проект с базовой реализацией можно здесь: <a href="https://github.com/sparklone/swiftui-views-preview-list" target="_blank">Github</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/debug-swiftui-views</guid><title>Отладка SwiftUI views</title><description>Как отслеживать создание и отрисовку SwiftUI views</description><link>https://sparklone.github.io/articles/debug-swiftui-views</link><pubDate>Sat, 11 Jul 2020 19:58:00 +0300</pubDate><content:encoded><![CDATA[<h1>Отладка SwiftUI views</h1><p>SwiftUI прикладывает массу усилий, чтобы UI не лагал при перерисовке. Если мы хотим лучше понимать как работает фреймворк под капотом - стоит копнуть чуть глубже.</p><p>По сути нас интересуют два события - когда View пересоздается, и когда запрашивается на самом деле body для перерисовки.</p><p>Это побудило меня создать обертку позволяющую отслеживать эти события</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">public struct</span> DebugView&lt;MainView: <span class="type">View</span>&gt;: <span class="type">View</span> {
    <span class="keyword">private let</span> view: <span class="type">MainView</span>
    <span class="keyword">private let</span> logType: <span class="type">LogType</span>

    <span class="keyword">private enum</span> LogType {
        <span class="keyword">case</span> onlyDescription(<span class="type">String</span>)
        <span class="keyword">case</span> descriptionAndDumpView(<span class="type">String</span>)
        <span class="keyword">case</span> dumpView
    }

    <span class="keyword">private var</span> about: <span class="type">String</span> {
        <span class="keyword">switch</span> logType {
            <span class="keyword">case let</span> .<span class="call">onlyDescription</span>(description):
                <span class="keyword">return</span> <span class="string">"</span>\(description)<span class="string">"</span>
            <span class="keyword">case let</span> .<span class="call">descriptionAndDumpView</span>(description):
                <span class="keyword">return</span> <span class="string">"</span>\(description)<span class="string">:</span> \(view)<span class="string">"</span>
            <span class="keyword">case</span> .<span class="dotAccess">dumpView</span>:
                <span class="keyword">return</span> <span class="string">"</span>\(view)<span class="string">"</span>
            }
        }

    <span class="keyword">public init</span>(view: <span class="type">MainView</span>, description: <span class="type">String</span>?, dumpView: <span class="type">Bool</span> = <span class="keyword">true</span>) {
        <span class="keyword">self</span>.<span class="property">view</span> = view
        <span class="keyword">if let</span> description = description {
            <span class="keyword">if</span> dumpView {
                logType = .<span class="call">descriptionAndDumpView</span>(description)
            } <span class="keyword">else</span> {
                logType = .<span class="call">onlyDescription</span>(description)
            }
        } <span class="keyword">else</span> {
            logType = .<span class="dotAccess">dumpView</span>
        }
        <span class="call">print</span>(<span class="string">"init:</span> \(about)<span class="string">"</span>)
    }

    <span class="keyword">public var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="call">print</span>(<span class="string">"body:</span> \(about)<span class="string">"</span>)
        <span class="keyword">return</span> view
    }
}

<span class="keyword">extension</span> <span class="type">View</span> {
    <span class="keyword">public func</span> debug() -&gt; <span class="type">DebugView</span>&lt;<span class="type">Self</span>&gt; {
        <span class="keyword">return</span> <span class="type">DebugView</span>(view: <span class="keyword">self</span>, description: <span class="keyword">nil</span>)
    }

    <span class="keyword">public func</span> debug(<span class="keyword">_</span> description: <span class="type">String</span>, dumpView: <span class="type">Bool</span> = <span class="keyword">false</span>) -&gt; <span class="type">DebugView</span>&lt;<span class="type">Self</span>&gt; {
        <span class="keyword">return</span> <span class="type">DebugView</span>(
            view: <span class="keyword">self</span>,
            description: description,
            dumpView: dumpView
        )
    }
}
</code></pre><p>Вот ее <a href="https://gist.github.com/sparklone/6f64156ed6de87c1020198d93f4c45a3">Gist</a></p><p>По большому счету, это View - прокси. Давайте попробуем поработать с этим. Создадим playground в котором мы посмотрим работу с SwiftUI views в динамике</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">private struct</span> MyListView: <span class="type">View</span> {
    <span class="keyword">@State var</span> numberOfViews: <span class="type">Int</span> = <span class="number">1</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(spacing: <span class="number">30</span>) {
            <span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
                <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>).<span class="call">debug</span>(<span class="string">"Text:</span> \(id)<span class="string">"</span>)
            }
            <span class="type">HStack</span> {
                <span class="type">Text</span>(<span class="string">"</span>\(numberOfViews)<span class="string">"</span>)
                <span class="type">Button</span>(<span class="string">"numberOfViews"</span>) {
                    <span class="keyword">self</span>.<span class="property">numberOfViews</span> += <span class="number">1</span>
                }
            }
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">MyListView</span>().<span class="call">debug</span>(<span class="string">"MyListView"</span>))
</code></pre><p>При старте в логах мы увидим</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">Text</span>: <span class="number">0</span>
body: <span class="type">Text</span>: <span class="number">0</span>

</code></pre><p>Выглядит разумно, при старте приложения система сначала создает MyListView, берет у нее body, видит что нужен один Text, создает его и затем уже у него просит body.</p><p>Нажимаем один раз на кнопку numberOfViews В логах добавится следующее:</p><pre><code>init: <span class="type">Text</span>: <span class="number">0</span>
init: <span class="type">Text</span>: <span class="number">1</span>
body: <span class="type">Text</span>: <span class="number">1</span>
</code></pre><p>А вот это уже интересно, мы видим, что пересоздания MyListView не происходит, что выглядит логично, а вот Text создается 2 раза (view стало 2 после увеличения счетчика), но body запросился только у нового элемента на экране.</p><p>Если еще раз нажать на кнопку numberOfViews увидим уже ожидаемое</p><pre><code>init: <span class="type">Text</span>: <span class="number">0</span>
init: <span class="type">Text</span>: <span class="number">1</span>
init: <span class="type">Text</span>: <span class="number">2</span>
body: <span class="type">Text</span>: <span class="number">2</span>
</code></pre><p>Т.е. body будет вызываться только для новых элементов.</p><p>Попробуем понять как и почему так работает система.</p><p>Создадим свою View - MyTextView и сделаем так, чтобы при каждом создании - генерировался уникальный контент</p><pre><code><span class="keyword">private struct</span> MyText: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(<span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>))<span class="string">"</span>)
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">MyText</span>().<span class="call">debug</span>(<span class="string">"MyText:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>На старте видим в логах</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">MyText</span>: <span class="number">0</span>
body: <span class="type">MyText</span>: <span class="number">0</span>

</code></pre><p>После нажатия на кнопку numberOfViews</p><pre><code>init: <span class="type">MyText</span>: <span class="number">0</span>
init: <span class="type">MyText</span>: <span class="number">1</span>
body: <span class="type">MyText</span>: <span class="number">1</span>
</code></pre><p>При этом, мы ожидаем, что на экране для ранее показанного элемента изменится число (random же как никак), но по факту число не меняется. Т.е. система создает MyText, но по всей видимости отбрасывает не перерисовывая. Почему? Потому что система считает, что все MyText - одинаковы, т.к. эта структура не реализует Equatable.</p><p>Проверим нашу догадку</p><pre><code><span class="keyword">private struct</span> MyTextEquatable: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>() {
        id = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>)
    }
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">MyTextEquatable</span>().<span class="call">debug</span>(<span class="string">"MyTextEquatable:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>Первый запуск</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
</code></pre><p>Нажимаем на кнопку</p><pre><code>init: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">0</span>
init: <span class="type">MyTextEquatable</span>: <span class="number">1</span>
body: <span class="type">MyTextEquatable</span>: <span class="number">1</span>
</code></pre><p>Заработало, это видно не только из логов, но и в preivew, после каждого нажатия кнопки - все числа меняются. Теперь кажется все встает на свои места, при каждом обновлении View система создает его детей (именно поэтому инициализаторы для View должны быть максимально легковесными, никакой "тяжелой" логики в конструктор помещать не стоит), сравнивает по протоколу Equatable - изменилось ли внутреннее состояние, если нет - система считает что перерисовка не нужна, т.к. View не обновилось.</p><p>Проверим, создадим следующее</p><pre><code><span class="keyword">private struct</span> StupidView: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">StupidView</span>, rhs: <span class="type">StupidView</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}
</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">StupidView</span>().<span class="call">debug</span>(<span class="string">"StupidView:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>При старте</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">StupidView</span>: <span class="number">0</span>
body: <span class="type">StupidView</span>: <span class="number">0</span>
</code></pre><p>После нажатия</p><pre><code>init: <span class="type">StupidView</span>: <span class="number">0</span>
init: <span class="type">StupidView</span>: <span class="number">1</span>
body: <span class="type">StupidView</span>: <span class="number">1</span>
</code></pre><p>Что за черт, мы же возвращаем false всегда при сравнении! Чтобы поотлаживать SwiftUI view надо будет создать полноценный проект и создать там новый файл с содержимым</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">private struct</span> MyListView: <span class="type">View</span> {
    <span class="keyword">@State var</span> numberOfViews: <span class="type">Int</span> = <span class="number">1</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(spacing: <span class="number">30</span>) {
            <span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
                <span class="type">StupidView</span>(id: id).<span class="call">debug</span>(<span class="string">"StupidView:</span> \(id)<span class="string">"</span>)
            }
            <span class="type">HStack</span> {
                <span class="type">Text</span>(<span class="string">"</span>\(numberOfViews)<span class="string">"</span>)
                <span class="type">Button</span>(<span class="string">"numberOfViews"</span>) {
                    <span class="keyword">self</span>.<span class="property">numberOfViews</span> += <span class="number">1</span>
                }
            }
        }
    }
}

<span class="keyword">private struct</span> StupidView: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> id: <span class="type">Int</span>
    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(id)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">StupidView</span>, rhs: <span class="type">StupidView</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}

<span class="keyword">struct</span> EquatableSwiftUIStupid_Previews: <span class="type">PreviewProvider</span> {
    <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">MyListView</span>()
    }
}
</code></pre><p>Если в preview вызывать контекстное меню у кнопки play - появится возможность сделать Debug preview.</p><br/><img src="https://sparklone.github.io/blog/images/debug-swiftui-views/debug-preview.png" width="300"/><br/><br/><br/><p>Что мы наблюдаем при отладке? Точки останова срабатывают внутри var body, но не срабатывают внутри static func == Почему то система не вызывает наш метод для сравнения. Очень уж умный SwiftUI. В итоге я нашел как это обойти - использовать вместо Int класс обертку Holder. Видимо в этом случае SwiftUI решает все же положиться на предоставленную реализацию, т.к. у нас уже не простой value type.</p><p>Проверим</p><pre><code><span class="keyword">private class</span> Holder {
    <span class="keyword">var</span> id: <span class="type">Int</span>

    <span class="keyword">init</span>(id: <span class="type">Int</span>) {
        <span class="keyword">self</span>.<span class="property">id</span> = id
    }
}

<span class="keyword">private struct</span> StupidViewWithHolder: <span class="type">View</span>, <span class="type">Equatable</span> {
    <span class="keyword">private let</span> holder: <span class="type">Holder</span>
    <span class="keyword">init</span>(holder: <span class="type">Holder</span>) {
        <span class="keyword">self</span>.<span class="property">holder</span> = holder
    }

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"</span>\(holder.<span class="property">id</span>)<span class="string">"</span>)
    }

    <span class="keyword">static func</span> == (lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">return false</span>
    }
}

</code></pre><p>Меняем вызов на</p><pre><code><span class="type">ForEach</span>(<span class="number">0</span>..&lt;numberOfViews, id: \.<span class="keyword">self</span>) { id <span class="keyword">in</span>
    <span class="type">StupidViewWithHolder</span>(holder: <span class="type">Holder</span>(id: id))
                    .<span class="call">debug</span>(<span class="string">"StupidViewWithHolder:</span> \(id)<span class="string">"</span>)
}
</code></pre><p>При старте</p><pre><code>init: <span class="type">MyListView</span>
body: <span class="type">MyListView</span>
init: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>

</code></pre><p>после нажатия</p><pre><code>init: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">0</span>
init: <span class="type">StupidViewWithHolder</span>: <span class="number">1</span>
body: <span class="type">StupidViewWithHolder</span>: <span class="number">1</span>
</code></pre><p>Наконец то мы добились реальной перерисовки элементов!</p><p>Стоит понимать, что не стоит на это закладываться при разработке, т.к. это внутреннее поведение SwiftUI, которое может измениться в любой момент. Но знания могут помочь понять что может вообще пойти не так и не тратить кучу времени на отладку реально сложных View. Теперь мы знаем очередной подводный камень SwiftUI, к тому же новый инструмент по дебагу View доказал свою состоятельность. Надеюсь было полезно )</p><p>Скачать Playground со всеми примерами из статьи можно здесь: <a href="https://github.com/sparklone/debug-swiftui-views">Playground</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://sparklone.github.io/articles/create-blog-using-swift-and-publish-and-deploy-to-github-pages</guid><title>Создаем блог на Swift с помощью Publish с размещением на GitHub Pages</title><description>Создаем блог на Swift с помощью Publish на GitHub Pages</description><link>https://sparklone.github.io/articles/create-blog-using-swift-and-publish-and-deploy-to-github-pages</link><pubDate>Fri, 10 Jul 2020 19:23:00 +0300</pubDate><content:encoded><![CDATA[<h1>Создаем блог на Swift с помощью Publish с размещением на GitHub Pages</h1><p>У меня уже есть блог, он на WordPress и я устал от всей этой свистопляски с обновлением версии, плагинов, возможности взлома и прочего. Это буквально убивает желание продолжать его развивать. Моя цель - делиться с миром своими мыслями и находками, но при этом иметь полный контроль над своим сайтом. С недавних пор Github Pages предоставила возможность хранить простенькие сайты у них. Никаких баз данных и PHP, статический сайт, как в старые добрые. Для блога - идеально. А т.к. процесс деплоя будет проходить через GitHub - будет прозрачная история всех изменений, и полный контроль над тем, что реально находится на сайте, трояны и прочая нечисть не пройдут.</p><p>Но они предлагают использовать Jekyll, статический генератор сайтов написанный на Ruby. Все же хочется отачивать мастерство в том языке, который ты используешь ежедневно, поэтому в качестве альтернативы я взял свежий статический генератор написанный на Swift от John Sundell.</p><p>Нам предстоит сделать 3 вещи:</p><ol><li><a href="#create-blog">создать блог на GitРub Pages</a></li><li><a href="#publish">разобраться с тем как работать с Publish</a></li><li><a href="#deploy">залить свой новый блог на GitРub Pages</a> <br/><br/> Итак, перейдем к пункту 1</li></ol><h2><a name="create-blog"></a> 1. Создадим блог на Github Pages.</h2><p>Официальная инструкция доступен по адресу <a href="https://pages.github.com">https://pages.github.com</a></p><p>Основное условие - login блога должен совпадать с вашим логином на GitHub. В моем случае это sparklone</p><ul><li>логинимся в GitHub</li><li>идем по адресу <a href="https://github.com/new">https://github.com/new</a></li><li>в качестве имени репозитория вводите <em>login</em>.github.io, в моем случае было sparklone.github.io</li><li>убеждаемся, что он будет Public</li><li>жмем Create Repository</li><li>все, наш блог уже доступен по адресу https://<em>login</em>.github.io</li></ul><br/><p>Но пока на сайте нет ни одного файл Можно переходить ко второму пункту</p><h2><a name="publish"></a> 2. Разберёмся с тем как работать с Publish</h2><p>Еще раз <a href="https://github.com/JohnSundell/Publish">Publish</a> - это статический генератор сайтов написанный на Swift, что позволяет выстраивать любую логику при генерации сайта, теги, карта сайта, rss, специфическая перелинковка. Все на что нам хватит фантазии. Одна из моих идей на будущее - попробовать писать статьи на двух языках, и чтобы настроенный шаблон умел это понимать и вставлять переключатель в статью к примеру. Не знаю дойдут ли когда нибудь до этого руки, но как идея - интересно.</p><p>Я предпочел установить напрямую через git, создал папку ~/Developer/tools и там выполнил</p><pre><code>git clone https://github.<span class="property">com</span>/<span class="type">JohnSundell</span>/<span class="type">Publish</span>.<span class="property">git</span>
cd <span class="type">Publish</span>
make
</code></pre><p>далее я создал папку где я планирую хранить свой сайт (точнее исходники его генератора), в моем случае это ~/Developer/my/blog</p><p>и внутри этой папки запускаем команду</p><pre><code>publish new
</code></pre><p>Это создаст новый сайт, список опций для команды можно узнать просто запустив в консоли publish</p><p><em>publish run</em> скомпилирует все исходники и запустит веб сервер на питоне (если прервать посредством Ctrl+C - веб сервер не умрет, и придется в процессах ковыряться чтобы убить Python)</p><p>Первая сборка занимает какое то время (подливаются нужные репозитории, компилируется все), при последующих запусках <em>publish run</em> - все происходит намного быстрее.</p><p>Открываем в браузере http://localhost:8000 и видим что получился за сайт</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/blog-initial.png" width="600"/><p>Не густо, но мы еще ничего собственно и не сделали, чтобы ожидать чего то большего.</p><p>Настройку стилей и прочие моменты я оставлю на потом. На сегодня вижу перед собой следующие задачи</p><ol><li>сделать изначальную настройку генератора для нашего сайта</li><li>поменять пути по которым будут лежать записи и настроить меню</li><li>добавить подсветку для исходных файлов и создание своей темы <br/><br/></li></ol><h3>1. Изначальная настройка генератора для нашего сайта</h3><br/><p>Посмотрим что нам сгенерировал Publish. Внутри папки будет файл Package.swift, его открываем XCode'ом (можно в консоли набрать open Package.swift), и это запускает процесс подтягивания всех нужных библиотек. На скрине видно что должно получится в итоге.</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/publish-initial-screen.png" width="600"/><p>Тестовая запись лежит в Content/posts/first-post.md Проверим, что мы можем что то изменить и это отразится на сайте Подправим текст в first-post.md (можно поменять дату, теги, описания, и сам контент)</p><p>В Xcode выбираем Mac в качества таргета для которого надо запускать и делаем Run проекту.</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/blog-how-to-run.png" width="600"/><p>После этого рефрешим веб страницу <a href="http://localhost:8000">http://localhost:8000</a></p><h4>2. Меняем пути по которым будут лежать записи и настраиваем меню</h4><p>Почему это важно сделать сразу? Если вы решите поменять пути после того как уже зальете часть постов - входящие ссылки на эти страницы станут невалидными, а т.к. это не свой сервер/VPS - будет довольно проблематично сделать редирект со старых ссылок на новые пути. Не невозможно (вот к примеру плагин для <a href="https://github.com/jekyll/jekyll-redirect-from">Jekyll</a>), но зачем создавать себе головную боль в будущем если можно ее избежать.</p><p>По умолчанию все записи лежать в папке posts. Учитывая что в дальнейшем хочется бить на категории, а posts - общее название, - лучше переименовать папку в articles. Так же не помешает добавить страницу about</p><p>Но наш генератор пока ничего не знает про это.</p><p>В main.swift поменяем на</p><pre><code><span class="keyword">struct</span> Blog: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> articles
        <span class="keyword">case</span> about
    }
}
</code></pre><p>Добавим файл <em>about.md</em> в папку <em>Content</em> и заполним немного информации о себе</p><p>К слову эту статью я пишу в XCode, редактируя md файл, и периодически запуская проект, чтобы посмотреть в браузере как это смотрится.</p><p>Я долго колебался заморачиваться ли с датой у файлов *.md, ну т.е. называть не my-article.md, а к примеру 2020-07-10-my-article.md. И все же решил отказаться от этой идеи. Т.к. в самих md файлах есть метаданные (поле date), это при желании позволит в будущем добавлять дату автоматически. И не придется следить за корректностью даты в имени файла, к тому же это убережет от расхождений, если в имени файла одна дата, а в метаданных внутри - другая. Недостатком такого решения я вижу то, что гипотетически могут в будущем быть коллизии в именах md файлов, но все таки это маловероятно, к тому же мы об этом узнаем при создании поста, а не сохранении.</p><h4>3. Добавляем подсветку для исходных файлов</h4><p>Автором генератора Publish так же была написана библиотека <a href="https://github.com/JohnSundell/Splash">Splash</a> позволяющая делать подсветку исходных кодов. Подключается она как package в Swift Package Manager</p><p>Открываем файл Package.swift и добавляем поддержку, по сути нужно добавить 2 строки Вот что получилось у меня</p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    name: <span class="string">"Blog"</span>,
    products: [
        .<span class="call">executable</span>(
            name: <span class="string">"Blog"</span>,
            targets: [<span class="string">"Blog"</span>]
        )
    ],
    dependencies: [
        .<span class="call">package</span>(name: <span class="string">"Publish"</span>, url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.6.0"</span>),
        .<span class="call">package</span>(name: <span class="string">"SplashPublishPlugin"</span>, url: <span class="string">"https://github.com/johnsundell/splashpublishplugin"</span>, from: <span class="string">"0.1.0"</span>)
    ],
    targets: [
        .<span class="call">target</span>(
            name: <span class="string">"Blog"</span>,
            dependencies: [
                <span class="string">"Publish"</span>,
                <span class="string">"SplashPublishPlugin"</span>
            ]
        )
    ]
)
</code></pre><p>А чтобы подсветка начала применяться при генерации нужно подклбючить плагин в main.swift</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>я поменял на</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">foundation</span>,
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><p>Не забываем добавить в <em>main.swift</em> импорт плагина <code></code><code>import SplashPublishPlugin</code><code></code></p><p>Если сгенерировать сайт сейчас мы увидим, что блоки с кодом будут выделяться, но не подсвечиваться, это связано с тем, что нужно добавить <a href="https://github.com/JohnSundell/Splash/blob/master/Examples/sundellsColors.css">CSS</a>, будем использовать тот, который по умолчанию используется автором плагина.</p><p>Но вот проблема - куда добавлять этот CSS? Если покопаться в исходниках, то станет видно, что все это решается на уровне темы. Тема у нас стандартная <em>foundation</em>, и она лежит в самом пакете <em>Publish</em> по пути <a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/Theme%2BFoundation.swift">Sources/Publish/API/Theme+Foundation.swift</a></p><p>Внутри своего проекта (Blog) в папке где лежит <em>main.swift</em> я создал подобный файл <em>Theme+Blog.swift</em> Так же внутри папки Resources я создал папку Blog и поместил туда файл styles.css Внутрь файла я поместил содержимое CSS от темы <a href="https://github.com/JohnSundell/Publish/blob/master/Resources/FoundationTheme/styles.css">Foundation</a> ну и CSS от <a href="https://github.com/JohnSundell/Splash/blob/master/Examples/sundellsColors.css">Splash</a> Да, лучше было бы разделить, а может вообще темы вынести в отдельный package, но не будем усложнять раньше времени.</p><p>Итого у меня в файле темы пришлось поменять на следующее</p><pre><code><span class="keyword">import</span> Plot
<span class="keyword">import</span> Publish

<span class="keyword">public extension</span> <span class="type">Theme</span> {
    <span class="keyword">static var</span> blog: <span class="type">Self</span> {
        <span class="type">Theme</span>(
            htmlFactory: <span class="type">BlogHTMLFactory</span>(),
            resourcePaths: [<span class="string">"resources/blog/styles.css"</span>]
        )
    }
}
</code></pre><p>Если бы мы добавили еще один css, нам потребовалось бы не только добавит его в resourcePaths, но так же добавлять в каждый head страниц, чего мне делать совершенно не хотелось в данный момент</p><pre><code>.<span class="call">head</span>(for: item, on: context.<span class="property">site</span>, stylesheetPaths: [<span class="string">"/styles.css"</span>, <span class="string">"/splash.css"</span>]),
</code></pre><p>Итого сейчас у меня в проекте файловая структура выглядит как то так:</p><img src="https://sparklone.github.io/blog/images/create-blog-using-swift-and-publish-and-deploy-to-github-pages/final-structure.png" width="400"/><h2><a name="deploy"></a> 3. Зальём свой новый блог на GitРub Pages</h2><p>Итак, воспользуемся встроенным инструментом Publish для заливки нашего блога. В <em>main.swift</em> добавим</p><pre><code>.<span class="call">deploy</span>(using: .<span class="call">gitHub</span>(<span class="string">"login/login.github.io"</span>, useSSH: <span class="keyword">false</span>))
</code></pre><p>итого у меня получилось</p><pre><code><span class="keyword">try</span> <span class="type">Blog</span>().<span class="call">publish</span>(
    withTheme: .<span class="dotAccess">blog</span>,
    deployedUsing: .<span class="call">gitHub</span>(<span class="string">"sparklone/sparklone.github.io"</span>, useSSH: <span class="keyword">false</span>),
    plugins: [.<span class="call">splash</span>(withClassPrefix: <span class="string">""</span>)]
)
</code></pre><p>Проверяем в последний раз, что все работает. Последний штрих - мне кажется, что нет смысла хранить в git нашего репозитория с темплейтами как строить сайт содержимое папки Output, для этого у нас будет отдельный репозиторий как раз таки <em>login.github.io</em> Если вы согласны - исключим эту папку из .gitignore, добавив туда строку <em>/Output</em> в конце Если все ок выполняем в консоли (из папки где мы выполняли publish new)</p><pre><code>git add .
git commit -m <span class="string">"post title or some description"</span>
git push origin
publish deploy
</code></pre><p>В течении минуты GitHub Pages подхватит ваши изменения и все появится онлайн.</p><br/><p>Поздравляю! )</p>]]></content:encoded></item></channel></rss>